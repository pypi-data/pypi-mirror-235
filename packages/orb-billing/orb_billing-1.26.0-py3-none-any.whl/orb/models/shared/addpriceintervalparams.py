"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import amountdiscountcreationparams as shared_amountdiscountcreationparams
from ..shared import newbpsprice as shared_newbpsprice
from ..shared import newbulkbpsprice as shared_newbulkbpsprice
from ..shared import newbulkprice as shared_newbulkprice
from ..shared import newmatrixprice as shared_newmatrixprice
from ..shared import newpackageprice as shared_newpackageprice
from ..shared import newpackagewithallocationprice as shared_newpackagewithallocationprice
from ..shared import newthresholdtotalamountprice as shared_newthresholdtotalamountprice
from ..shared import newtieredbpsprice as shared_newtieredbpsprice
from ..shared import newtieredpackageprice as shared_newtieredpackageprice
from ..shared import newtieredprice as shared_newtieredprice
from ..shared import newtieredwithminimumprice as shared_newtieredwithminimumprice
from ..shared import newunitprice as shared_newunitprice
from ..shared import percentagediscountcreationparams as shared_percentagediscountcreationparams
from ..shared import priceintervalfixedfeequantitytransitionparams as shared_priceintervalfixedfeequantitytransitionparams
from ..shared import usagediscountcreationparams as shared_usagediscountcreationparams
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from enum import Enum
from orb import utils
from typing import Optional, Union



@dataclasses.dataclass
class AddPriceIntervalParamsDiscounts:
    pass

class AddPriceIntervalParamsEndDateEndDate(str, Enum):
    r"""The end date of the price interval. This is the date that the price will stop billing on the subscription."""
    START_OF_TERM = 'start_of_term'
    END_OF_TERM = 'end_of_term'



@dataclasses.dataclass
class AddPriceIntervalParamsEndDate:
    pass

class AddPriceIntervalParamsStartDateStartDate(str, Enum):
    r"""The start date of the price interval. This is the date that the price will start billing on the subscription."""
    START_OF_TERM = 'start_of_term'
    END_OF_TERM = 'end_of_term'



@dataclasses.dataclass
class AddPriceIntervalParamsStartDate:
    pass


@dataclass_json(undefined=Undefined.EXCLUDE)

@dataclasses.dataclass
class AddPriceIntervalParams:
    start_date: Union[datetime, AddPriceIntervalParamsStartDateStartDate] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('start_date') }})
    r"""The start date of the price interval. This is the date that the price will start billing on the subscription."""
    discounts: Optional[list[Union[shared_amountdiscountcreationparams.AmountDiscountCreationParams, shared_percentagediscountcreationparams.PercentageDiscountCreationParams, shared_usagediscountcreationparams.UsageDiscountCreationParams]]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('discounts') }})
    r"""A list of discounts to initialize on the price interval."""
    end_date: Optional[Union[datetime, AddPriceIntervalParamsEndDateEndDate]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('end_date') }})
    r"""The end date of the price interval. This is the date that the price will stop billing on the subscription."""
    external_price_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('external_price_id') }})
    r"""The external price id of the price to add to the subscription."""
    fixed_fee_quantity_transitions: Optional[list[shared_priceintervalfixedfeequantitytransitionparams.PriceIntervalFixedFeeQuantityTransitionParams]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fixed_fee_quantity_transitions') }})
    r"""A list of fixed fee quantity transitions to initialize on the price interval."""
    maximum_amount: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maximum_amount') }})
    r"""The maximum amount that will be billed for this price interval for a given billing period."""
    minimum_amount: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('minimum_amount') }})
    r"""The minimum amount that will be billed for this price interval for a given billing period."""
    price: Optional[Union[shared_newunitprice.NewUnitPrice, shared_newpackageprice.NewPackagePrice, shared_newmatrixprice.NewMatrixPrice, shared_newtieredprice.NewTieredPrice, shared_newtieredbpsprice.NewTieredBpsPrice, shared_newbpsprice.NewBpsPrice, shared_newbulkbpsprice.NewBulkBpsPrice, shared_newbulkprice.NewBulkPrice, shared_newthresholdtotalamountprice.NewThresholdTotalAmountPrice, shared_newtieredpackageprice.NewTieredPackagePrice, shared_newtieredwithminimumprice.NewTieredWithMinimumPrice, shared_newpackagewithallocationprice.NewPackageWithAllocationPrice]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price'), 'decoder': utils.decoder_with_discriminator('model_type') }})
    r"""The definition of a new price to create and add to the subscription."""
    price_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('price_id') }})
    r"""The id of the price to add to the subscription."""
    

