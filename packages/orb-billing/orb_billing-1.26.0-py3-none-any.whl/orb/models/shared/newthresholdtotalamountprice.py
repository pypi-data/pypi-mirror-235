"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from orb import utils
from typing import Any, Optional, Union

class NewThresholdTotalAmountPriceCadence(str, Enum):
    r"""The cadence to bill for this price on."""
    ANNUAL = 'annual'
    MONTHLY = 'monthly'
    QUARTERLY = 'quarterly'



@dataclasses.dataclass
class NewThresholdTotalAmountPriceFixedPriceQuantity:
    pass

class NewThresholdTotalAmountPriceModelType(str, Enum):
    THRESHOLD_TOTAL_AMOUNT = 'threshold_total_amount'


@dataclass_json(undefined=Undefined.EXCLUDE)

@dataclasses.dataclass
class NewThresholdTotalAmountPrice:
    cadence: NewThresholdTotalAmountPriceCadence = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cadence') }})
    r"""The cadence to bill for this price on."""
    currency: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currency') }})
    r"""An ISO 4217 currency string for which this price is billed in."""
    item_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('item_id') }})
    r"""The id of the item the plan will be associated with."""
    model_type: NewThresholdTotalAmountPriceModelType = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('model_type') }})
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""The name of the price."""
    threshold_total_amount_config: dict[str, Any] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('threshold_total_amount_config') }})
    billable_metric_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('billable_metric_id') }})
    r"""The id of the billable metric for the price. Only needed if the price is usage-based."""
    billed_in_advance: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('billed_in_advance') }})
    r"""If the Price represents a fixed cost, the price will be billed in-advance if this is true, and in-arrears if this is false."""
    external_price_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('external_price_id') }})
    r"""An alias for the price."""
    fixed_price_quantity: Optional[Union[float, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fixed_price_quantity') }})
    r"""If the Price represents a fixed cost, this represents the quantity of units applied."""
    invoice_grouping_key: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('invoice_grouping_key') }})
    r"""The property used to group this price on an invoice"""
    

