# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['generic_scpi_driver']

package_data = \
{'': ['*']}

install_requires = \
['pyserial>=3,<4', 'pyvisa-py>=0.7.0,<0.8.0', 'pyvisa>=1,<2']

setup_kwargs = {
    'name': 'generic-scpi-driver',
    'version': '1.4',
    'description': 'A generic template for creating python object-based drivers for SCPI hardware devices which communicate via VISA. Compatible with ARTIQ  installed with [artiq] modifier',
    'long_description': 'Generic SCPI driver\n===================\n\n.. image:: https://img.shields.io/pypi/pyversions/generic-scpi-driver\n   :alt: PyPI - Python Version\n\nA generic driver generator for devices controlled via (virtual) COM ports using SCPI commands.\nCreates a python class for controlling your device. \n\nThis class is compatible with the ARTIQ experimental control system and,\nif desired, a network ARTIQ controller is also generated. \n\nInstallation\n------------\n\nInstall the package and its dependancies with::\n\n    pip install generic-scpi-driver\n\n\nIf you\'d like to use the ARTIQ network controller generation, instead install with::\n\n    pip install generic-scpi-driver[artiq]\n\nUsage\n-----\n\nBasics\n######\n\nTo make a driver, simply inherit from the GenericDriver class. To define commands, call\n`_register_query` on the class (not on objects of the class). For example:\n\n.. code-block:: python\n\n    from generic_scpi_driver import GenericDriver\n\n    class SimpleDriver(GenericDriver):\n        \'\'\'A driver for my simple SCPI device\'\'\'\n\n    SimpleDriver._register_query("get_identity", "*IDN")\n\nThis creates a class called ``SimpleDriver`` which has a constuctor ``__init__``, a ``close()`` method\nand a new method called ``get_identity()`` which takes no parameters and returns a string. You could open a connection to your device like this:\n\n.. code-block:: python\n\n    dev = SimpleDriver(\n        id="COM10",\n        baud_rate=57600\n    )\n\n    # This sends the command "*IDN\\n" to the device and returns the response\n    identity = dev.get_identity()\n\nParameters\n##########\n\nFor more complex commands, you can specify parameters for the command:\n\n.. code-block:: python\n\n    SimpleDriver._register_query(\n        "set_voltage",\n        "VOLT",\n        args=[\n            GenericDriver.Arg(name="channel"),\n            GenericDriver.Arg(name="voltage"),\n        ]\n    )\n\nThis would allow you to call:\n\n.. code-block:: python\n\n    # Using positional arguments\n    dev.set_voltage(0, 5.4)\n\n    # ...or keyword arguments\n    dev.set_voltage(channel=0, voltage=5.4)\n\nParameters can be validated by passing a custom function (which may accept any\nsingle parameter and must return a string to be sent to the device, or throw an error):\n\n.. code-block:: python\n\n    def check_voltage_in_limits(v):\n        voltage = float(v)\n        if voltage > 10:\n            raise ValueError("Voltage too high")\n        return str(voltage)\n\n    SimpleDriver._register_query(\n        "set_voltage",\n        "VOLT",\n        args=[\n            GenericDriver.Arg(name="channel", validator=lambda: str(int(x))),\n            GenericDriver.Arg(name="voltage", validator=check_voltage_in_limits, default=0.0,\n        ]\n    )\n\nReturn values\n#############\n\nReturn values are, by default, the string returned by the SCPI device in response to your command. \nIf you\'d prefer to process these, you can pass a ``response_parser`` function:\n\n.. code-block:: python\n\n    SimpleDriver._register_query(\n        "count_foobars",\n        "COUN",\n        response_parser=int,\n    )\n\n    SimpleDriver._register_query(\n        "list_foobars",\n        "LIST",\n        response_parser=lambda x: x.split(","),\n    )\n\nIf your device doesn\'t give any response at all, you can set\n``response_parser=None`` and the driver won\'t attempt to listen for a respose. \n\nError checking\n##############\n\nYou can also add error checking to your commands. Pass a function as\n``response_validator`` and it will be called with the output from the device\n(not the parsed output of ``response_parser``) as its input. The\n``response_validator``\'s return value will be ignored: it\'s only job is to raise\nan exception if needed. E.g.\n\n.. code-block:: python\n\n    def check_for_error(s):\n        if "error" in s.lower():\n            raise RuntimeError("Error returned by device: {}".format(s))\n    \n    SimpleDriver._register_query(\n        "do_something",\n        "DOOO",\n        response_validator=check_for_error,\n    )\n\nAsyncronous operation\n#####################\n\nBy default, all methods are syncronous. If you\'d prefer async operation, pass ``coroutine=True`` \nto ``_register_query``. This creates a new thread for the serial call and returns an ``asyncio``\ncoroutine. Note that you have to call these using an async loop which is a whole topic of python\nprogramming. This is particularly useful for ARTIQ drivers, since ARTIQ handles coroutines\nautomatically. \n\nCustom methods\n##############\n\nThe method generation is intended to be quite flexible, but if you really need custom logic there\'s\nnothing to stop you writing your own methods. You can use ``self.instr`` to access the\n``pyvisa.Resource`` for your device. Use the wrappers ``with_handler`` to cause the driver to issue a\nVISA ``.flush()`` if an error occurs and ``with_lock`` to ensure that only one method access the device\nat a time (only relevant in multi-threaded applications). \n\n.. code-block:: python\n\n    from generic_scpi_driver import GenericDriver, with_lock, with_handler\n\n    class SimpleDriver(GenericDriver):\n        \'\'\'A driver for my simple SCPI device\'\'\'\n\n        @with_handler\n        @with_lock\n        def do_complex_thing(self):\n            \'\'\'Do something complex\'\'\'\n            response = self.instr.query("COMP 1 2 3")\n            return int(response) + 5\n\nStartup checking\n################\n\nIt can be useful to check on startup if communicatio with a device has been\nestablished successfully. To do this, define a method in the class called\n``check_connection``. Return value is ignored, but this method will be called\nwhen the object is constucted and has the chance to raise an exception. Example:\n\n.. code-block:: python\n\n    from generic_scpi_driver import GenericDriver, with_lock, with_handler\n\n    class SimpleDriver(GenericDriver):\n        \'\'\'A driver for my simple SCPI device\'\'\'\n\n        def check_connection(self):\n            idn = self.get_identity()\n            if idn != "My device":\n                raise RuntimeError(f"Bad device identity: got \'{idn}\'")\n\n    # Note that it\'s fine to define functions later which get used in methods\n    # defined previously\n    SimpleDriver._register_query("get_identity", "*IDN")\n\nSimulation mode\n###############\n\nThe constuctor accepts a keyword parameter ``simulation=True`` to return a simulation device, for running\noffline unit tests. This won\'t work unless you also register a simulator device with a method ``query`` which\ntakes a string and returns a string. For example:\n\n.. code-block:: python\n\n    class Simulator:\n        def query(s):\n            if s == "*IDN":\n                return "Simulator device"\n            else:\n                return "ERROR"\n\n    class SimpleDriver(GenericDriver):\n        pass\n\n    SimpleDriver._register_simulator(Simulator)\n    SimpleDriver._register_query("get_identity", "*IDN")\n\n    dev = SimpleDriver(id="fake", simulation=True)\n\n    dev.get_identity()  # returns "Simulator device"\n\nARTIQ Controllers\n#################\n\nTo get a network controller for use by the ARTIQ controller manager, just make a python module like:\n\n.. code-block:: python\n\n    from generic_scpi_driver import get_controller_func\n\n    from .my_driver import SimpleDriver\n\n    # Makes a controller called "SimpleDriver" which listens to port 3300 by default\n    main = get_controller_func("SimpleDriver", 3300, SimpleDriver)\n\n\n    if __name__ == "__main__":\n        main()\n\nRegister this ``main`` function in your ``setup.py`` like so:\n\n.. code-block:: python\n\n    setup(\n        ...\n        entry_points={\n            "console_scripts": [\n                "artiq_simple_device=my_driver_package.my_driver_controller:main",\n            ]\n        },\n    )\n\nAfter installing your package using `pip install -e .` as normal, you should be able to call\n``artiq_simple_device`` on the command line to launch a controller for your device. \n\nDevelopment\n-----------\n\nFor developing the package, you\'ll need a few more packages. Install with::\n\n    pip install -e .[dev,artiq]\n\nAuthors\n-------\n\n`generic_scpi_driver` was written by `Charles Baynham <charles.baynham@npl.co.uk>`_.\n',
    'author': 'Charles Baynham',
    'author_email': 'charles.baynham@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8,<3.13',
}


setup(**setup_kwargs)
