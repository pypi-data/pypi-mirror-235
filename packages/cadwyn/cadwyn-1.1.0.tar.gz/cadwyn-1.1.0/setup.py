# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['cadwyn', 'cadwyn.structure']

package_data = \
{'': ['*']}

install_requires = \
['fastapi-header-versioning>=1.1.0',
 'fastapi>=0.96.1',
 'pydantic>=1.10.0,<2.0.0',
 'typing-extensions']

extras_require = \
{'cli': ['typer>=0.7.0']}

entry_points = \
{'console_scripts': ['cadwyn = cadwyn.__main__:app']}

setup_kwargs = {
    'name': 'cadwyn',
    'version': '1.1.0',
    'description': 'Modern Stripe-like API versioning in FastAPI',
    'long_description': '# Cadwyn\n\nModern [Stripe-like](https://stripe.com/blog/api-versioning) API versioning in FastAPI\n\n---\n\n<p align="center">\n<a href="https://github.com/ovsyanka83/cadwyn/actions?query=workflow%3ATests+event%3Apush+branch%3Amain" target="_blank">\n    <img src="https://github.com/Ovsyanka83/cadwyn/actions/workflows/test.yaml/badge.svg?branch=main&event=push" alt="Test">\n</a>\n<a href="https://codecov.io/gh/ovsyanka83/cadwyn" target="_blank">\n    <img src="https://img.shields.io/codecov/c/github/ovsyanka83/cadwyn?color=%2334D058" alt="Coverage">\n</a>\n<a href="https://pypi.org/project/cadwyn/" target="_blank">\n    <img alt="PyPI" src="https://img.shields.io/pypi/v/cadwyn?color=%2334D058&label=pypi%20package" alt="Package version">\n</a>\n<a href="https://pypi.org/project/cadwyn/" target="_blank">\n    <img src="https://img.shields.io/pypi/pyversions/cadwyn?color=%2334D058" alt="Supported Python versions">\n</a>\n</p>\n\n## Installation\n\n```bash\npip install cadwyn\n```\n\n## Who is this for?\n\nCadwyn allows you to support a single version of your code, auto-generating the code/routes for older versions. You keep versioning encapsulated in small and independent "version change" modules while your business logic knows nothing about versioning.\n\nIts approach will be useful if you want to:\n\n1. Support many API versions for a long time\n2. Effortlessly backport features and bugfixes to all of your versions\n\nOtherwise, more conventional methods of API versioning may be preferable.\n\n## Tutorial\n\nThis guide provides a step-by-step tutorial for setting up automatic API versioning using Cadwyn library. I will illustrate this with an example of a User API, where we will be implementing changes to a User\'s address.\n\n### A dummy setup\n\nHere is an initial API setup where the User has a single address. We will be implementing two routes - one for creating a user and another for retrieving user details. We\'ll be using "int" for ID for simplicity.\n\nThe first API you come up with usually doesn\'t require more than one address -- why bother?\n\nSo we create our file with schemas:\n\n```python\nfrom pydantic import BaseModel\n\n\nclass UserCreateRequest(BaseModel):\n    address: str\n\n\nclass UserResource(BaseModel):\n    id: int\n    address: str\n```\n\nAnd we create our file with routes:\n\n```python\nfrom versions.latest.users import UserCreateRequest, UserResource\nfrom cadwyn import VersionedAPIRouter\n\nrouter = VersionedAPIRouter()\n\n\n@router.post("/users", response_model=UserResource)\nasync def create_user(payload: UserCreateRequest):\n    return {\n        "id": 83,\n        "address": payload.address,\n    }\n\n\n@router.get("/users/{user_id}", response_model=UserResource)\nasync def get_user(user_id: int):\n    return {\n        "id": user_id,\n        "address": "123 Example St",\n    }\n```\n\n### Turning address into a list\n\nDuring our development, we have realized that the initial API design was wrong and that addresses should have always been a list because the user wants to have multiple addresses to choose from so now we have to change the type of the "address" field to the list of strings.\n\n```python\nfrom pydantic import BaseModel, Field\n\n\nclass UserCreateRequest(BaseModel):\n    addresses: list[str] = Field(min_items=1)\n\n\nclass UserResource(BaseModel):\n    id: int\n    addresses: list[str]\n```\n\n```python\n@router.post("/users", response_model=UserResource)\nasync def create_user(payload: UserCreateRequest):\n    return {\n        "id": 83,\n        "addresses": payload.addresses,\n    }\n\n\n@router.get("/users/{user_id}", response_model=UserResource)\nasync def get_user(user_id: int):\n    return {\n        "id": user_id,\n        "addresses": ["123 Example St", "456 Main St"],\n    }\n```\n\nBut every user of ours will now have their API integration broken. To prevent that, we have to introduce API versioning. There aren\'t many methods of doing that. Most of them force you to either duplicate your schemas, your endpoints, or your entire app instance. And it makes sense, really: duplication is the only way to make sure that you will not break old versions with your new versions; the bigger the piece you duplicating -- the safer. Of course, the safest being duplicating the entire app instance and even having a separate database. But that is expensive and makes it either impossible to make breaking changes often or to support many versions. As a result, either you need infinite resources, very long development cycles, or your users will need to often migrate from version to version.\n\nStripe has come up [with a solution](https://stripe.com/blog/api-versioning): let\'s have one latest app version whose responses get migrated to older versions and let\'s describe changes between these versions using migrations. This approach allows them to keep versions for **years** without dropping them. Obviously, each breaking change is still bad and each version still makes our system more complex and expensive, but their approach gives us a chance to minimize that. Additionally, it allows us backport features and bugfixes to older versions. However, you will also be backporting bugs, which is a sad consequence of eliminating duplication.\n\nCadwyn is heavily inspired by this approach so let\'s continue our tutorial and now try to combine the two versions we created using versioning.\n\n### Creating the Migration\n\nWe need to create a migration to handle changes between these versions. For every endpoint whose `response_model` is `UserResource`, this migration will convert the list of addresses back to a single address when migrating to the previous version. Yes, migrating **back**: you might be used to database migrations where we write upgrade migration and downgrade migration but here our goal is to have an app of latest version and to describe what older versions looked like in comparison to it. That way the old versions are frozen in migrations and you can **almost** safely forget about them.\n\n```python\nfrom pydantic import Field\nfrom cadwyn.structure import (\n    schema,\n    VersionChange,\n    convert_response_to_previous_version_for,\n    RequestInfo,\n    ResponseInfo,\n)\n\n\nclass ChangeAddressToList(VersionChange):\n    description = (\n        "Change user address to a list of strings to "\n        "allow the user to specify multiple addresses"\n    )\n    instructions_to_migrate_to_previous_version = [\n        # You should use schema inheritance if you don\'t want to repeat yourself in such cases\n        schema(UserCreateRequest).field("addresses").didnt_exist,\n        schema(UserCreateRequest).field("address").existed_as(type=str, info=Field()),\n        schema(UserResource).field("addresses").didnt_exist,\n        schema(UserResource).field("address").existed_as(type=str, info=Field()),\n    ]\n\n    @convert_request_to_next_version_for(UserCreateRequest)\n    def change_address_to_multiple_items(request: RequestInfo):\n        request.body["addresses"] = [request.body.pop("address")]\n\n    @convert_response_to_previous_version_for(UserResource)\n    def change_addresses_to_single_item(response: ResponseInfo) -> None:\n        response.body["address"] = response.body.pop("addresses")[0]\n```\n\nSee how we are popping the first address from the list? This is only guaranteed to be possible because we specified earlier that `min_items` for `addresses` must be `1`. If we didn\'t, then the user would be able to create a user in a newer version that would be impossible to represent in the older version. I.e. If anyone tried to get that user from the older version, they would get a `ResponseValidationError` because the user wouldn\'t have data for a mandatory `address` field. You need to always keep in mind tht API versioning is only for versioning your **API**, your interface. Your versions must still be completely compatible in terms of data. If they are not, then you are versioning your data and you should really go with a separate app instance. Otherwise, your users will have a hard time migrating back and forth between API versions and so many unexpected errors.\n\nSee how we added a migration not only for response but also for request? This will allow our business logic to stay completely the same, no matter which version it was called from. Cadwyn will always give your business logic the request model from the latest version or from a custom schema [if you want to](#internal-request-schemas).\n\n### Grouping Version Changes\n\nFinally, we group the version changes in the `VersionBundle` class. This represents the different versions of your API and the changes between them. You can add any "version changes" to any version. For simplicity, let\'s use versions 2002 and 2001 which means that we had a single address in API in 2001 and added addresses as a list in 2002\'s version.\n\n```python\nfrom cadwyn.structure import Version, VersionBundle\nfrom datetime import date\nfrom contextvars import ContextVar\n\napi_version_var = ContextVar("api_version_var")\n\nversions = VersionBundle(\n    Version(date(2002, 1, 1), ChangeAddressToList),\n    Version(date(2001, 1, 1)),\n    api_version_var=api_version_var,\n)\n```\n\nThat\'s it. You\'re done with describing things. Now you just gotta ask cadwyn to do the rest for you. We\'ll need the VersionedAPIRouter we used previously, our API versions, and the module representing the latest versions of our schemas.\n\n```python\nfrom versions import latest, api_version_var\nfrom cadwyn import generate_code_for_versioned_packages, generate_versioned_routers\n\ngenerate_code_for_versioned_packages(latest, versions)\nrouter_versions = generate_versioned_routers(\n    router,\n    versions=versions,\n    latest_schemas_module=latest,\n)\napi_version_var.set(date(2002, 1, 1))\nuvicorn.run(router_versions[date(2002, 1, 1)])\n```\n\nCadwyn has generated multiple things in this code:\n\n* Two versions of our schemas: one for each API version\n* Two versions of our API router: one for each API version\n\nYou can now just pick a router by its version and run it separately or use a parent router/app to specify the logic by which you\'d like to pick a version. I recommend using a header-based router with version dates as headers. And yes, that\'s how Stripe does it.\n\nNote that cadwyn migrates your response data based on the `api_version_var` context variable so you must set it with each request. `cadwyn.get_cadwyn_dependency` does that for you automatically on every request based on header value.\n\nObviously, this was just a simple example and cadwyn has a lot more features so if you\'re interested -- take a look at the reference.\n\n### Examples\n\nPlease, see [tutorial examples](https://github.com/Ovsyanka83/cadwyn/tree/main/tests/test_tutorial) for the fully working version of the project above.\n\n## Important warnings\n\n1. The goal of Cadwyn is to **minimize** the impact of versioning on your business logic. It provides all necessary tools to prevent you from **ever** checking for a concrete version in your code. So please, if you are tempted to check something like `api_version_var.get() >= date(2022, 11, 11)` -- please, take another look into [reference](#version-changes-with-side-effects) section. I am confident that you will find a better solution there.\n2. I ask you to be very detailed in your descriptions for version changes. Spending these 5 extra minutes will potentially save you tens of hours in the future when everybody forgets when, how, and why the version change was made.\n3. Cadwyn doesn\'t edit your imports when generating schemas so if you make any imports from versioned code to versioned code, I would suggest using [relative imports](https://docs.python.org/3/reference/import.html#package-relative-imports) to make sure that they will still work as expected after code generation.\n\n## Reference\n\n### CLI\n\nCadwyn has an optional CLI interface that can be installed with `pip install cadwyn[cli]`.\n\n#### Code generation\n\nYou can essentially run `generate_code_for_versioned_packages` using this CLI instead of creating a script file.\n\n* `cadwyn generate-code-for-versioned-packages path.to.latest.package path.to.version.bundle:my_version_bundle`\n* `cadwyn generate-code-for-versioned-packages path.to.latest.package path.to.version.bundle:func_that_returns_version_bundle`\n\n#### Version checks\n\nRun  `cadwyn --version`  to check current version of Cadwyn\n\n### Endpoints\n\nNote that the endpoint constructor contains a second argument that describes the methods of the endpoints you would like to edit. If you have two routes for a single endpoint and you put both of their methods into the instruction -- both of them are going to be changed as you would expect.\n\n#### Defining endpoints that didn\'t exist in new versions\n\nIf you had an endpoint in old version but do not have it in a new one, you must still define it but mark it as deleted.\n\n```python\n@router.only_exists_in_older_versions\n@router.get("/my_old_endpoint")\nasync def my_old_endpoint():\n    ...\n```\n\nand then define it as existing in one of the older versions:\n\n```python\nfrom cadwyn.structure import VersionChange, endpoint\n\n\nclass MyChange(VersionChange):\n    description = "..."\n    instructions_to_migrate_to_previous_version = [\n        endpoint("/my_old_endpoint", ["GET"]).existed,\n    ]\n```\n\n#### Defining endpoints that didn\'t exist in old versions\n\nIf you have an endpoint in your new version that must not exist in older versions, you define it as usual and then mark it as "non-existing" in old versions:\n\n```python\nfrom cadwyn.structure import VersionChange, endpoint\n\n\nclass MyChange(VersionChange):\n    description = "..."\n    instructions_to_migrate_to_previous_version = [\n        endpoint("/my_new_endpoint", ["GET"]).didnt_exist,\n    ]\n```\n\n#### Changing endpoint attributes\n\nIf you want to change any attribute of your endpoint in a new version, you can return the attribute\'s value in all older versions like so:\n\n```python\nfrom cadwyn.structure import VersionChange, endpoint\n\n\nclass MyChange(VersionChange):\n    description = "..."\n    instructions_to_migrate_to_previous_version = [\n        endpoint("/my_endpoint", ["GET"]).had(description="My old description"),\n    ]\n```\n\n#### Dealing with endpoint duplicates\n\nSometimes, when you\'re doing some advanced changes in between versions, you will need to rewrite your endpoint function entirely. So essentially you\'d have the following structure:\n\n```python\nfrom fastapi.params import Param\nfrom fastapi.headers import Header\nfrom typing import Annotated\nfrom cadwyn import VersionedAPIRouter\n\nrouter = VersionedAPIRouter()\n\n\n@router.only_exists_in_older_versions\n@router.get("/users")\ndef get_users_by_name_before_we_started_using_params(\n    user_name: Annotated[str, Header()]\n):\n    """Do some logic with user_name"""\n\n\n@router.get("/users")\ndef get_users_by_name(user_name: Annotated[str, Param()]):\n    """Do some logic with user_name"""\n```\n\nAs you see, these two functions have the same methods and paths. And when you have many versions, you can have even more functions like these two. So how do we ask cadwyn to restore only one of them and delete the other one?\n\n```python\nfrom cadwyn.structure import VersionChange, endpoint\n\n\nclass UseParamsInsteadOfHeadersForUserNameFiltering(VersionChange):\n    description = (\n        "Use params instead of headers for user name filtering in GET /users "\n        "because using headers is a bad API practice in such scenarios."\n    )\n    instructions_to_migrate_to_previous_version = [\n        # We don\'t have to specify the name here because there\'s only one such deleted endpoint\n        endpoint("/users", ["GET"]).existed,\n        # We do have to specify the name because we now have two existing endpoints after the instruction above\n        endpoint("/users", ["GET"], func_name="get_users_by_name").didnt_exist,\n    ]\n```\n\nSo by using a more concrete `func_name`, we are capable to distinguish between different functions that affect the same routes.\n\n### Enums\n\n#### Adding enum members\n\nNote that adding enum members **can** be a breaking change unlike adding optional fields to a schema. For example, if I return a list of entities, each of which has some type, and I add a new type -- then my client\'s code is likely to break.\n\nSo I suggest adding enum members in new versions as well.\n\n```python\nfrom cadwyn.structure import VersionChange, enum\nfrom enum import auto\n\n\nclass MyChange(VersionChange):\n    description = "..."\n    instructions_to_migrate_to_previous_version = [\n        enum(my_enum).had(foo="baz", bar=auto()),\n    ]\n```\n\n#### Removing enum members\n\n```python\nfrom cadwyn.structure import VersionChange, enum\n\n\nclass MyChange(VersionChange):\n    description = "..."\n    instructions_to_migrate_to_previous_version = [\n        enum(my_enum).didnt_have("foo", "bar"),\n    ]\n```\n\n### Schemas\n\n#### Add a field\n\n```python\nfrom pydantic import Field\nfrom cadwyn.structure import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = "..."\n    instructions_to_migrate_to_previous_version = [\n        schema(MySchema)\n        .field("foo")\n        .existed_as(type=list[str], info=Field(description="Foo")),\n    ]\n```\n\nYou can also specify any string in place of type:\n\n```python\nschema(MySchema).field("foo").existed_as(type="AnythingHere")\n```\n\nIt is often the case that you want to add a type that has not been imported in your schemas yet. You can use `import_from` and optionally `import_as` to do this:\n\n```python\nschema(MySchema).field("foo").existed_as(\n    type=MyOtherSchema, import_from="..some_module", import_as="Foo"\n)\n```\n\nWhich will render as:\n\n```python\nfrom ..some_module import MyOtherSchema as Foo\nfrom pydantic import BaseModel, Field\n\n\nclass MySchema(BaseModel):\n    foo: Foo = Field()\n```\n\n#### Remove a field\n\n```python\nfrom cadwyn.structure import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = "..."\n    instructions_to_migrate_to_previous_version = [\n        schema(MySchema).field("foo").didnt_exist,\n    ]\n```\n\n#### Change a field\n\n```python\nfrom cadwyn.structure import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = "..."\n    instructions_to_migrate_to_previous_version = [\n        schema(MySchema).field("foo").had(description="Foo"),\n    ]\n```\n\n#### Rename a schema\n\nIf you wish to rename your schema to make sure that its name is different in openapi.json:\n\n```python\nfrom cadwyn.structure import VersionChange, schema\n\n\nclass MyChange(VersionChange):\n    description = "..."\n    instructions_to_migrate_to_previous_version = [\n        schema(MySchema).had(name="OtherSchema"),\n    ]\n```\n\nwhich will replace all references to this schema with the new name.\n\n### Data migration\n\n#### Response data migration\n\nAs described in the tutorial, cadwyn can convert your response data into older versions. It does so by running your "migration" functions whenever it encounters a version change:\n\n```python\nfrom cadwyn.structure import VersionChange, convert_response_to_previous_version_for\nfrom typing import Any\n\n\nclass ChangeAddressToList(VersionChange):\n    description = "..."\n\n    @convert_response_to_previous_version_for(MyEndpointResponseModel)\n    def change_addresses_to_single_item(response: ResponseInfo) -> None:\n        response.body["address"] = response.body.pop("addresses")[0]\n```\n\nIt is done by applying a versioning decorator to each endpoint with the given `response_model` which automatically detects the API version by getting it from the [contextvar](#api-version-header-and-context-variables) and applying all version changes until the selected version in reverse. Note that if the version is not set, then no changes will be applied.\n\n#### Request data migration\n\n```python\nfrom cadwyn.structure import VersionChange, convert_request_to_next_version_for\nfrom typing import Any\nfrom my_schemas.latest import UserCreateRequest\n\n\nclass ChangeAddressToList(VersionChange):\n    description = "..."\n\n    @convert_request_to_next_version_for(UserCreateRequest)\n    def change_addresses_to_single_item(request: RequestInfo) -> None:\n        request.body["addresses"] = [request.body.pop("address")]\n```\n\n#### Internal request schemas\n\nLet\'s say our `CreateUserRequest` had a field `email` which was `str | None` in version 1 but became a required `str` in version 2. How do we migrate our request from version 1 to version 2? The schema from version 2 will simply raise an error if you try to put a `None` into the `email` field.\n\nThat\'s because the understanding that you migrate your requests to the latest schema is incomplete. In reality, your goal is to migrate them to some schema that represents the union of all schemas. Latest schema is the best candidate because our business logic is closest to it and API changes are usually additive in nature. But as you see from the aforementioned situation, that\'s not always the case, which is why sometimes we need another schema: an internal representation of the request which not confined by our API and can have any structure we want. Now let\'s solve our email problem using an internal schema.\n\n```python\nfrom .versioned_schemas.latest import CreateUserRequest\nfrom cadwyn import internal_representation_of\n\n\n@internal_representation_of(CreateUserRequest)\nclass InternalCreateUserRequest(CreateUserRequest):\n    email: str | None\n```\n\nNow cadwyn will always use `InternalCreateUserRequest` when pushing body field into your business logic instead of `CreateUserRequest`. Note that users will not be able to use any fields from the internal schema and their requests will still be validated by your regular schemas. So even if you added a field `foo` in an internal schema, and your user has passed this field in the body of the request, this field will not get to the internal schema because it will be removed at the moment of validation (or even an error will occur if you use `extra="ignore"`).\n\nI would, however, advise you put it in an unversioned directory and inherit it from your latest schema to minimize the chance of human errors.\n\n### Version changes with side effects\n\nSometimes you will use API versioning to handle a breaking change in your **business logic**, not in the schemas themselves. In such cases, it is tempting to add a version check and just follow the new business logic such as:\n\n```python\nif api_version_var.get() >= date(2022, 11, 11):\n    # do new logic here\n    ...\n```\n\nIn cadwyn, this approach is highly discouraged. It is recommended that you avoid side effects like this at any cost because each one makes your core logic harder to understand. But if you cannot, then I urge you to at least abstract away versions and versioning from your business logic which will make your code much easier to read.\n\nTo simplify this, cadwyn has a special `VersionChangeWithSideEffects` class. It makes finding dangerous versions that have side effects much easier and provides a nice abstraction for checking whether we are on a version where these side effects have been applied.\n\nAs an example, let\'s use the tutorial section\'s case with the user and their address. Let\'s say that we use an external service to check whether user\'s address is listed in it and return 400 response if it is not. Let\'s also say that we only added this check in the newest version.\n\n```python\nfrom cadwyn.structure import VersionChangeWithSideEffects\n\n\nclass UserAddressIsCheckedInExternalService(VersionChangeWithSideEffects):\n    description = (\n        "User\'s address is now checked for existense in an external service. "\n        "If it doesn\'t exist there, a 400 code is returned."\n    )\n```\n\nThen we will have the following check in our business logic:\n\n```python\nfrom src.versions import versions, UserAddressIsCheckedInExternalService\n\n\nasync def create_user(payload):\n    if UserAddressIsCheckedInExternalService.is_applied:\n        check_user_address_exists_in_an_external_service(payload.address)\n    ...\n```\n\nSo this change can be contained in any version -- your business logic doesn\'t know which version it has and shouldn\'t.\n\n### API Version header and context variables\n\nCadwyn automatically converts your data to a correct version and has "version checks" when dealing with side effects as described in [the section above](#version-changes-with-side-effects). It can only do so using a special [context variable](https://docs.python.org/3/library/contextvars.html) that stores the current API version.\n\nUse `cadwyn.get_cadwyn_dependency` to get a `fastapi.Depends` that automatically sets this contextvar based on a header name that you pick.\n\nYou can also set the variable yourself or even pass a different compatible contextvar to your `cadwyn.VersionBundle` constructor.\n\n## Similar projects\n\nThe following projects are trying to accomplish similar results with a lot more simplistic functionality.\n\n* <https://github.com/sjkaliski/pinned>\n* <https://github.com/phillbaker/gates>\n* <https://github.com/lukepolo/laravel-api-migrations>\n* <https://github.com/tomschlick/request-migrations>\n* <https://github.com/keygen-sh/request_migrations>\n',
    'author': 'Stanislav Zmiev',
    'author_email': 'zmievsa@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/ovsyanka83/cadwyn',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'extras_require': extras_require,
    'entry_points': entry_points,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
