# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ComputeInstanceNetworkInterface',
    'DatabaseGrafana',
    'DatabaseKafka',
    'DatabaseMysql',
    'DatabaseOpensearch',
    'DatabaseOpensearchDashboards',
    'DatabaseOpensearchIndexPattern',
    'DatabaseOpensearchIndexTemplate',
    'DatabasePg',
    'DatabaseRedis',
    'DatabaseTimeouts',
    'ElasticIPHealthcheck',
    'IAMAPIKeyTimeouts',
    'IAMOrgPolicyServices',
    'IAMOrgPolicyServicesRule',
    'IAMOrgPolicyTimeouts',
    'IAMRolePolicy',
    'IAMRolePolicyServices',
    'IAMRolePolicyServicesRule',
    'IAMRoleTimeouts',
    'InstancePoolInstance',
    'NLBServiceHealthcheck',
    'SKSClusterOidc',
    'SecurityGroupRulesEgress',
    'SecurityGroupRulesIngress',
    'GetComputeInstanceListInstanceResult',
    'GetDatabaseURITimeoutsResult',
    'GetDomainRecordFilterResult',
    'GetDomainRecordRecordResult',
    'GetElasticIPHealthcheckResult',
    'GetIAMAPIKeyTimeoutsResult',
    'GetIAMOrgPolicyServicesResult',
    'GetIAMOrgPolicyServicesRuleResult',
    'GetIAMOrgPolicyTimeoutsResult',
    'GetIAMRolePolicyResult',
    'GetIAMRolePolicyServicesResult',
    'GetIAMRolePolicyServicesRuleResult',
    'GetIAMRoleTimeoutsResult',
    'GetInstancePoolInstanceResult',
    'GetInstancePoolListPoolResult',
    'GetInstancePoolListPoolInstanceResult',
    'GetNLBServiceListServiceResult',
    'GetNLBServiceListServiceHealthcheckResult',
    'GetNLBServiceListTimeoutsResult',
    'GetSKSClusterListClusterResult',
    'GetSKSClusterListClusterOidcResult',
    'GetSKSClusterOidcResult',
    'GetSKSNodepoolListNodepoolResult',
]

@pulumi.output_type
class ComputeInstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ComputeInstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ComputeInstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ComputeInstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: str,
                 ip_address: Optional[str] = None):
        """
        :param str network_id: The exoscale*private*network (ID) to attach to the instance.
        :param str ip_address: The IPv4 address to request as static DHCP lease if the network interface is attached to a *managed* private network.
        """
        ComputeInstanceNetworkInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_id=network_id,
            ip_address=ip_address,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_id: str,
             ip_address: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("network_id", network_id)
        if ip_address is not None:
            _setter("ip_address", ip_address)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        """
        The exoscale*private*network (ID) to attach to the instance.
        """
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IPv4 address to request as static DHCP lease if the network interface is attached to a *managed* private network.
        """
        return pulumi.get(self, "ip_address")


@pulumi.output_type
class DatabaseGrafana(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grafanaSettings":
            suggest = "grafana_settings"
        elif key == "ipFilters":
            suggest = "ip_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseGrafana. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseGrafana.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseGrafana.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grafana_settings: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None):
        """
        :param str grafana_settings: Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        """
        DatabaseGrafana._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grafana_settings=grafana_settings,
            ip_filters=ip_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grafana_settings: Optional[str] = None,
             ip_filters: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if grafana_settings is not None:
            _setter("grafana_settings", grafana_settings)
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)

    @property
    @pulumi.getter(name="grafanaSettings")
    def grafana_settings(self) -> Optional[str]:
        """
        Grafana configuration settings in JSON format (`exo dbaas type show grafana --settings=grafana` for reference).
        """
        return pulumi.get(self, "grafana_settings")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")


@pulumi.output_type
class DatabaseKafka(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableCertAuth":
            suggest = "enable_cert_auth"
        elif key == "enableKafkaConnect":
            suggest = "enable_kafka_connect"
        elif key == "enableKafkaRest":
            suggest = "enable_kafka_rest"
        elif key == "enableSaslAuth":
            suggest = "enable_sasl_auth"
        elif key == "enableSchemaRegistry":
            suggest = "enable_schema_registry"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "kafkaConnectSettings":
            suggest = "kafka_connect_settings"
        elif key == "kafkaRestSettings":
            suggest = "kafka_rest_settings"
        elif key == "kafkaSettings":
            suggest = "kafka_settings"
        elif key == "schemaRegistrySettings":
            suggest = "schema_registry_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseKafka. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseKafka.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseKafka.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_cert_auth: Optional[bool] = None,
                 enable_kafka_connect: Optional[bool] = None,
                 enable_kafka_rest: Optional[bool] = None,
                 enable_sasl_auth: Optional[bool] = None,
                 enable_schema_registry: Optional[bool] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 kafka_connect_settings: Optional[str] = None,
                 kafka_rest_settings: Optional[str] = None,
                 kafka_settings: Optional[str] = None,
                 schema_registry_settings: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param bool enable_cert_auth: Enable certificate-based authentication method.
        :param bool enable_kafka_connect: Enable Kafka Connect.
        :param bool enable_kafka_rest: Enable Kafka REST.
        :param bool enable_sasl_auth: Enable SASL-based authentication method.
        :param bool enable_schema_registry: Enable Schema Registry.
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param str kafka_connect_settings: Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        :param str kafka_rest_settings: Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        :param str kafka_settings: Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        :param str schema_registry_settings: Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        :param str version: Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        DatabaseKafka._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_cert_auth=enable_cert_auth,
            enable_kafka_connect=enable_kafka_connect,
            enable_kafka_rest=enable_kafka_rest,
            enable_sasl_auth=enable_sasl_auth,
            enable_schema_registry=enable_schema_registry,
            ip_filters=ip_filters,
            kafka_connect_settings=kafka_connect_settings,
            kafka_rest_settings=kafka_rest_settings,
            kafka_settings=kafka_settings,
            schema_registry_settings=schema_registry_settings,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_cert_auth: Optional[bool] = None,
             enable_kafka_connect: Optional[bool] = None,
             enable_kafka_rest: Optional[bool] = None,
             enable_sasl_auth: Optional[bool] = None,
             enable_schema_registry: Optional[bool] = None,
             ip_filters: Optional[Sequence[str]] = None,
             kafka_connect_settings: Optional[str] = None,
             kafka_rest_settings: Optional[str] = None,
             kafka_settings: Optional[str] = None,
             schema_registry_settings: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enable_cert_auth is not None:
            _setter("enable_cert_auth", enable_cert_auth)
        if enable_kafka_connect is not None:
            _setter("enable_kafka_connect", enable_kafka_connect)
        if enable_kafka_rest is not None:
            _setter("enable_kafka_rest", enable_kafka_rest)
        if enable_sasl_auth is not None:
            _setter("enable_sasl_auth", enable_sasl_auth)
        if enable_schema_registry is not None:
            _setter("enable_schema_registry", enable_schema_registry)
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)
        if kafka_connect_settings is not None:
            _setter("kafka_connect_settings", kafka_connect_settings)
        if kafka_rest_settings is not None:
            _setter("kafka_rest_settings", kafka_rest_settings)
        if kafka_settings is not None:
            _setter("kafka_settings", kafka_settings)
        if schema_registry_settings is not None:
            _setter("schema_registry_settings", schema_registry_settings)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="enableCertAuth")
    def enable_cert_auth(self) -> Optional[bool]:
        """
        Enable certificate-based authentication method.
        """
        return pulumi.get(self, "enable_cert_auth")

    @property
    @pulumi.getter(name="enableKafkaConnect")
    def enable_kafka_connect(self) -> Optional[bool]:
        """
        Enable Kafka Connect.
        """
        return pulumi.get(self, "enable_kafka_connect")

    @property
    @pulumi.getter(name="enableKafkaRest")
    def enable_kafka_rest(self) -> Optional[bool]:
        """
        Enable Kafka REST.
        """
        return pulumi.get(self, "enable_kafka_rest")

    @property
    @pulumi.getter(name="enableSaslAuth")
    def enable_sasl_auth(self) -> Optional[bool]:
        """
        Enable SASL-based authentication method.
        """
        return pulumi.get(self, "enable_sasl_auth")

    @property
    @pulumi.getter(name="enableSchemaRegistry")
    def enable_schema_registry(self) -> Optional[bool]:
        """
        Enable Schema Registry.
        """
        return pulumi.get(self, "enable_schema_registry")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="kafkaConnectSettings")
    def kafka_connect_settings(self) -> Optional[str]:
        """
        Kafka Connect configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-connect` for reference).
        """
        return pulumi.get(self, "kafka_connect_settings")

    @property
    @pulumi.getter(name="kafkaRestSettings")
    def kafka_rest_settings(self) -> Optional[str]:
        """
        Kafka REST configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka-rest` for reference).
        """
        return pulumi.get(self, "kafka_rest_settings")

    @property
    @pulumi.getter(name="kafkaSettings")
    def kafka_settings(self) -> Optional[str]:
        """
        Kafka configuration settings in JSON format (`exo dbaas type show kafka --settings=kafka` for reference).
        """
        return pulumi.get(self, "kafka_settings")

    @property
    @pulumi.getter(name="schemaRegistrySettings")
    def schema_registry_settings(self) -> Optional[str]:
        """
        Schema Registry configuration settings in JSON format (`exo dbaas type show kafka --settings=schema-registry` for reference)
        """
        return pulumi.get(self, "schema_registry_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Kafka major version (`exo dbaas type show kafka` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseMysql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupSchedule":
            suggest = "backup_schedule"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "mysqlSettings":
            suggest = "mysql_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseMysql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseMysql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseMysql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_schedule: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 mysql_settings: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str admin_password: A custom administrator account password (may only be set at creation time).
        :param str admin_username: A custom administrator account username (may only be set at creation time).
        :param str backup_schedule: The automated backup schedule (`HH:MM`).
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param str mysql_settings: MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        :param str version: MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        DatabaseMysql._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_password=admin_password,
            admin_username=admin_username,
            backup_schedule=backup_schedule,
            ip_filters=ip_filters,
            mysql_settings=mysql_settings,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_password: Optional[str] = None,
             admin_username: Optional[str] = None,
             backup_schedule: Optional[str] = None,
             ip_filters: Optional[Sequence[str]] = None,
             mysql_settings: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if admin_password is not None:
            _setter("admin_password", admin_password)
        if admin_username is not None:
            _setter("admin_username", admin_username)
        if backup_schedule is not None:
            _setter("backup_schedule", backup_schedule)
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)
        if mysql_settings is not None:
            _setter("mysql_settings", mysql_settings)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[str]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="mysqlSettings")
    def mysql_settings(self) -> Optional[str]:
        """
        MySQL configuration settings in JSON format (`exo dbaas type show mysql --settings=mysql` for reference).
        """
        return pulumi.get(self, "mysql_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        MySQL major version (`exo dbaas type show mysql` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseOpensearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forkFromService":
            suggest = "fork_from_service"
        elif key == "indexPatterns":
            suggest = "index_patterns"
        elif key == "indexTemplate":
            suggest = "index_template"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "keepIndexRefreshInterval":
            suggest = "keep_index_refresh_interval"
        elif key == "maxIndexCount":
            suggest = "max_index_count"
        elif key == "recoveryBackupName":
            suggest = "recovery_backup_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dashboards: Optional['outputs.DatabaseOpensearchDashboards'] = None,
                 fork_from_service: Optional[str] = None,
                 index_patterns: Optional[Sequence['outputs.DatabaseOpensearchIndexPattern']] = None,
                 index_template: Optional['outputs.DatabaseOpensearchIndexTemplate'] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 keep_index_refresh_interval: Optional[bool] = None,
                 max_index_count: Optional[int] = None,
                 recovery_backup_name: Optional[str] = None,
                 settings: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param 'DatabaseOpensearchDashboardsArgs' dashboards: OpenSearch Dashboards settings
        :param str fork_from_service: ❗ Service name
        :param Sequence['DatabaseOpensearchIndexPatternArgs'] index_patterns: (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        :param 'DatabaseOpensearchIndexTemplateArgs' index_template: Template settings for all new indexes
        :param Sequence[str] ip_filters: Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        :param bool keep_index_refresh_interval: Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        :param int max_index_count: Maximum number of indexes to keep (Minimum value is `0`)
        :param str recovery_backup_name: ❗ Name of a backup to recover from
        :param str settings: OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        :param str version: ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
        DatabaseOpensearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dashboards=dashboards,
            fork_from_service=fork_from_service,
            index_patterns=index_patterns,
            index_template=index_template,
            ip_filters=ip_filters,
            keep_index_refresh_interval=keep_index_refresh_interval,
            max_index_count=max_index_count,
            recovery_backup_name=recovery_backup_name,
            settings=settings,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dashboards: Optional['outputs.DatabaseOpensearchDashboards'] = None,
             fork_from_service: Optional[str] = None,
             index_patterns: Optional[Sequence['outputs.DatabaseOpensearchIndexPattern']] = None,
             index_template: Optional['outputs.DatabaseOpensearchIndexTemplate'] = None,
             ip_filters: Optional[Sequence[str]] = None,
             keep_index_refresh_interval: Optional[bool] = None,
             max_index_count: Optional[int] = None,
             recovery_backup_name: Optional[str] = None,
             settings: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dashboards is not None:
            _setter("dashboards", dashboards)
        if fork_from_service is not None:
            _setter("fork_from_service", fork_from_service)
        if index_patterns is not None:
            _setter("index_patterns", index_patterns)
        if index_template is not None:
            _setter("index_template", index_template)
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)
        if keep_index_refresh_interval is not None:
            _setter("keep_index_refresh_interval", keep_index_refresh_interval)
        if max_index_count is not None:
            _setter("max_index_count", max_index_count)
        if recovery_backup_name is not None:
            _setter("recovery_backup_name", recovery_backup_name)
        if settings is not None:
            _setter("settings", settings)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def dashboards(self) -> Optional['outputs.DatabaseOpensearchDashboards']:
        """
        OpenSearch Dashboards settings
        """
        return pulumi.get(self, "dashboards")

    @property
    @pulumi.getter(name="forkFromService")
    def fork_from_service(self) -> Optional[str]:
        """
        ❗ Service name
        """
        return pulumi.get(self, "fork_from_service")

    @property
    @pulumi.getter(name="indexPatterns")
    def index_patterns(self) -> Optional[Sequence['outputs.DatabaseOpensearchIndexPattern']]:
        """
        (can be used multiple times) Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max*index*count to 0 will do nothing and the pattern gets ignored.
        """
        return pulumi.get(self, "index_patterns")

    @property
    @pulumi.getter(name="indexTemplate")
    def index_template(self) -> Optional['outputs.DatabaseOpensearchIndexTemplate']:
        """
        Template settings for all new indexes
        """
        return pulumi.get(self, "index_template")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        Allow incoming connections from this list of CIDR address block, e.g. `["10.20.0.0/16"]
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="keepIndexRefreshInterval")
    def keep_index_refresh_interval(self) -> Optional[bool]:
        """
        Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
        """
        return pulumi.get(self, "keep_index_refresh_interval")

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[int]:
        """
        Maximum number of indexes to keep (Minimum value is `0`)
        """
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter(name="recoveryBackupName")
    def recovery_backup_name(self) -> Optional[str]:
        """
        ❗ Name of a backup to recover from
        """
        return pulumi.get(self, "recovery_backup_name")

    @property
    @pulumi.getter
    def settings(self) -> Optional[str]:
        """
        OpenSearch-specific settings, in json. e.g.`jsonencode({thread_pool_search_size: 64})`. Use `exo x get-dbaas-settings-opensearch` to get a list of available settings.
        """
        return pulumi.get(self, "settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        ❗ OpenSearch major version (`exo dbaas type show opensearch` for reference)
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseOpensearchDashboards(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxOldSpaceSize":
            suggest = "max_old_space_size"
        elif key == "requestTimeout":
            suggest = "request_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearchDashboards. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearchDashboards.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearchDashboards.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 max_old_space_size: Optional[int] = None,
                 request_timeout: Optional[int] = None):
        """
        :param bool enabled: Enable or disable OpenSearch Dashboards (default: true).
        :param int max_old_space_size: Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max*old*space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch. (default: 128).
        :param int request_timeout: Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch (default: 30000)
        """
        DatabaseOpensearchDashboards._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            max_old_space_size=max_old_space_size,
            request_timeout=request_timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             max_old_space_size: Optional[int] = None,
             request_timeout: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)
        if max_old_space_size is not None:
            _setter("max_old_space_size", max_old_space_size)
        if request_timeout is not None:
            _setter("request_timeout", request_timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable or disable OpenSearch Dashboards (default: true).
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxOldSpaceSize")
    def max_old_space_size(self) -> Optional[int]:
        """
        Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max*old*space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch. (default: 128).
        """
        return pulumi.get(self, "max_old_space_size")

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[int]:
        """
        Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch (default: 30000)
        """
        return pulumi.get(self, "request_timeout")


@pulumi.output_type
class DatabaseOpensearchIndexPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxIndexCount":
            suggest = "max_index_count"
        elif key == "sortingAlgorithm":
            suggest = "sorting_algorithm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearchIndexPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearchIndexPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearchIndexPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_index_count: Optional[int] = None,
                 pattern: Optional[str] = None,
                 sorting_algorithm: Optional[str] = None):
        """
        :param int max_index_count: Maximum number of indexes to keep before deleting the oldest one (Minimum value is `0`)
        :param str pattern: fnmatch pattern
        :param str sorting_algorithm: `alphabetical` or `creation_date`.
        """
        DatabaseOpensearchIndexPattern._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_index_count=max_index_count,
            pattern=pattern,
            sorting_algorithm=sorting_algorithm,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_index_count: Optional[int] = None,
             pattern: Optional[str] = None,
             sorting_algorithm: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_index_count is not None:
            _setter("max_index_count", max_index_count)
        if pattern is not None:
            _setter("pattern", pattern)
        if sorting_algorithm is not None:
            _setter("sorting_algorithm", sorting_algorithm)

    @property
    @pulumi.getter(name="maxIndexCount")
    def max_index_count(self) -> Optional[int]:
        """
        Maximum number of indexes to keep before deleting the oldest one (Minimum value is `0`)
        """
        return pulumi.get(self, "max_index_count")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        """
        fnmatch pattern
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter(name="sortingAlgorithm")
    def sorting_algorithm(self) -> Optional[str]:
        """
        `alphabetical` or `creation_date`.
        """
        return pulumi.get(self, "sorting_algorithm")


@pulumi.output_type
class DatabaseOpensearchIndexTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mappingNestedObjectsLimit":
            suggest = "mapping_nested_objects_limit"
        elif key == "numberOfReplicas":
            suggest = "number_of_replicas"
        elif key == "numberOfShards":
            suggest = "number_of_shards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOpensearchIndexTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOpensearchIndexTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOpensearchIndexTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mapping_nested_objects_limit: Optional[int] = None,
                 number_of_replicas: Optional[int] = None,
                 number_of_shards: Optional[int] = None):
        """
        :param int mapping_nested_objects_limit: The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. (Default is 10000. Minimum value is `0`, maximum value is `100000`.)
        :param int number_of_replicas: The number of replicas each primary shard has. (Minimum value is `0`, maximum value is `29`)
        :param int number_of_shards: The number of primary shards that an index should have. (Minimum value is `1`, maximum value is `1024`.)
        """
        DatabaseOpensearchIndexTemplate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mapping_nested_objects_limit=mapping_nested_objects_limit,
            number_of_replicas=number_of_replicas,
            number_of_shards=number_of_shards,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mapping_nested_objects_limit: Optional[int] = None,
             number_of_replicas: Optional[int] = None,
             number_of_shards: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if mapping_nested_objects_limit is not None:
            _setter("mapping_nested_objects_limit", mapping_nested_objects_limit)
        if number_of_replicas is not None:
            _setter("number_of_replicas", number_of_replicas)
        if number_of_shards is not None:
            _setter("number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="mappingNestedObjectsLimit")
    def mapping_nested_objects_limit(self) -> Optional[int]:
        """
        The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. (Default is 10000. Minimum value is `0`, maximum value is `100000`.)
        """
        return pulumi.get(self, "mapping_nested_objects_limit")

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[int]:
        """
        The number of replicas each primary shard has. (Minimum value is `0`, maximum value is `29`)
        """
        return pulumi.get(self, "number_of_replicas")

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[int]:
        """
        The number of primary shards that an index should have. (Minimum value is `1`, maximum value is `1024`.)
        """
        return pulumi.get(self, "number_of_shards")


@pulumi.output_type
class DatabasePg(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "adminUsername":
            suggest = "admin_username"
        elif key == "backupSchedule":
            suggest = "backup_schedule"
        elif key == "ipFilters":
            suggest = "ip_filters"
        elif key == "pgSettings":
            suggest = "pg_settings"
        elif key == "pgbouncerSettings":
            suggest = "pgbouncer_settings"
        elif key == "pglookoutSettings":
            suggest = "pglookout_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabasePg. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabasePg.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabasePg.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 admin_username: Optional[str] = None,
                 backup_schedule: Optional[str] = None,
                 ip_filters: Optional[Sequence[str]] = None,
                 pg_settings: Optional[str] = None,
                 pgbouncer_settings: Optional[str] = None,
                 pglookout_settings: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str admin_password: A custom administrator account password (may only be set at creation time).
        :param str admin_username: A custom administrator account username (may only be set at creation time).
        :param str backup_schedule: The automated backup schedule (`HH:MM`).
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param str pg_settings: PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        :param str pgbouncer_settings: PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        :param str pglookout_settings: pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        :param str version: PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        DatabasePg._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_password=admin_password,
            admin_username=admin_username,
            backup_schedule=backup_schedule,
            ip_filters=ip_filters,
            pg_settings=pg_settings,
            pgbouncer_settings=pgbouncer_settings,
            pglookout_settings=pglookout_settings,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_password: Optional[str] = None,
             admin_username: Optional[str] = None,
             backup_schedule: Optional[str] = None,
             ip_filters: Optional[Sequence[str]] = None,
             pg_settings: Optional[str] = None,
             pgbouncer_settings: Optional[str] = None,
             pglookout_settings: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if admin_password is not None:
            _setter("admin_password", admin_password)
        if admin_username is not None:
            _setter("admin_username", admin_username)
        if backup_schedule is not None:
            _setter("backup_schedule", backup_schedule)
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)
        if pg_settings is not None:
            _setter("pg_settings", pg_settings)
        if pgbouncer_settings is not None:
            _setter("pgbouncer_settings", pgbouncer_settings)
        if pglookout_settings is not None:
            _setter("pglookout_settings", pglookout_settings)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        A custom administrator account password (may only be set at creation time).
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[str]:
        """
        A custom administrator account username (may only be set at creation time).
        """
        return pulumi.get(self, "admin_username")

    @property
    @pulumi.getter(name="backupSchedule")
    def backup_schedule(self) -> Optional[str]:
        """
        The automated backup schedule (`HH:MM`).
        """
        return pulumi.get(self, "backup_schedule")

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="pgSettings")
    def pg_settings(self) -> Optional[str]:
        """
        PostgreSQL configuration settings in JSON format (`exo dbaas type show pg --settings=pg` for reference).
        """
        return pulumi.get(self, "pg_settings")

    @property
    @pulumi.getter(name="pgbouncerSettings")
    def pgbouncer_settings(self) -> Optional[str]:
        """
        PgBouncer configuration settings in JSON format (`exo dbaas type show pg --settings=pgbouncer` for reference).
        """
        return pulumi.get(self, "pgbouncer_settings")

    @property
    @pulumi.getter(name="pglookoutSettings")
    def pglookout_settings(self) -> Optional[str]:
        """
        pglookout configuration settings in JSON format (`exo dbaas type show pg --settings=pglookout` for reference).
        """
        return pulumi.get(self, "pglookout_settings")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        PostgreSQL major version (`exo dbaas type show pg` for reference; may only be set at creation time).
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class DatabaseRedis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipFilters":
            suggest = "ip_filters"
        elif key == "redisSettings":
            suggest = "redis_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseRedis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseRedis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseRedis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_filters: Optional[Sequence[str]] = None,
                 redis_settings: Optional[str] = None):
        """
        :param Sequence[str] ip_filters: A list of CIDR blocks to allow incoming connections from.
        :param str redis_settings: Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        DatabaseRedis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_filters=ip_filters,
            redis_settings=redis_settings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_filters: Optional[Sequence[str]] = None,
             redis_settings: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ip_filters is not None:
            _setter("ip_filters", ip_filters)
        if redis_settings is not None:
            _setter("redis_settings", redis_settings)

    @property
    @pulumi.getter(name="ipFilters")
    def ip_filters(self) -> Optional[Sequence[str]]:
        """
        A list of CIDR blocks to allow incoming connections from.
        """
        return pulumi.get(self, "ip_filters")

    @property
    @pulumi.getter(name="redisSettings")
    def redis_settings(self) -> Optional[str]:
        """
        Redis configuration settings in JSON format (`exo dbaas type show redis --settings=redis` for reference).
        """
        return pulumi.get(self, "redis_settings")


@pulumi.output_type
class DatabaseTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None,
                 read: Optional[str] = None,
                 update: Optional[str] = None):
        """
        :param str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        DatabaseTimeouts._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create=create,
            delete=delete,
            read=read,
            update=update,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create: Optional[str] = None,
             delete: Optional[str] = None,
             read: Optional[str] = None,
             update: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if create is not None:
            _setter("create", create)
        if delete is not None:
            _setter("delete", delete)
        if read is not None:
            _setter("read", read)
        if update is not None:
            _setter("update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @property
    @pulumi.getter
    def update(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class ElasticIPHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "strikesFail":
            suggest = "strikes_fail"
        elif key == "strikesOk":
            suggest = "strikes_ok"
        elif key == "tlsSkipVerify":
            suggest = "tls_skip_verify"
        elif key == "tlsSni":
            suggest = "tls_sni"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticIPHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticIPHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticIPHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mode: str,
                 port: int,
                 interval: Optional[int] = None,
                 strikes_fail: Optional[int] = None,
                 strikes_ok: Optional[int] = None,
                 timeout: Optional[int] = None,
                 tls_skip_verify: Optional[bool] = None,
                 tls_sni: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param str mode: The healthcheck mode (`tcp`, `http` or `https`; may only be set at creation time).
        :param int port: The healthcheck target port (must be between `1` and `65535`).
        :param int interval: The healthcheck interval (seconds; must be between `5` and `300`; default: `10`).
        :param int strikes_fail: The number of failed healthcheck attempts before considering the target unhealthy (must be between `1` and `20`; default: `2`).
        :param int strikes_ok: The number of successful healthcheck attempts before considering the target healthy (must be between `1` and `20`; default: `3`).
        :param int timeout: The time before considering a healthcheck probing failed (seconds; must be between `2` and `60`; default: `3`).
        :param bool tls_skip_verify: Disable TLS certificate verification for healthcheck in `https` mode (boolean; default: `false`).
        :param str tls_sni: The healthcheck server name to present with SNI in `https` mode.
        :param str uri: The healthcheck target URI (required in `http(s)` modes).
        """
        ElasticIPHealthcheck._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            port=port,
            interval=interval,
            strikes_fail=strikes_fail,
            strikes_ok=strikes_ok,
            timeout=timeout,
            tls_skip_verify=tls_skip_verify,
            tls_sni=tls_sni,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: str,
             port: int,
             interval: Optional[int] = None,
             strikes_fail: Optional[int] = None,
             strikes_ok: Optional[int] = None,
             timeout: Optional[int] = None,
             tls_skip_verify: Optional[bool] = None,
             tls_sni: Optional[str] = None,
             uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("mode", mode)
        _setter("port", port)
        if interval is not None:
            _setter("interval", interval)
        if strikes_fail is not None:
            _setter("strikes_fail", strikes_fail)
        if strikes_ok is not None:
            _setter("strikes_ok", strikes_ok)
        if timeout is not None:
            _setter("timeout", timeout)
        if tls_skip_verify is not None:
            _setter("tls_skip_verify", tls_skip_verify)
        if tls_sni is not None:
            _setter("tls_sni", tls_sni)
        if uri is not None:
            _setter("uri", uri)

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        The healthcheck mode (`tcp`, `http` or `https`; may only be set at creation time).
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The healthcheck target port (must be between `1` and `65535`).
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        The healthcheck interval (seconds; must be between `5` and `300`; default: `10`).
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="strikesFail")
    def strikes_fail(self) -> Optional[int]:
        """
        The number of failed healthcheck attempts before considering the target unhealthy (must be between `1` and `20`; default: `2`).
        """
        return pulumi.get(self, "strikes_fail")

    @property
    @pulumi.getter(name="strikesOk")
    def strikes_ok(self) -> Optional[int]:
        """
        The number of successful healthcheck attempts before considering the target healthy (must be between `1` and `20`; default: `3`).
        """
        return pulumi.get(self, "strikes_ok")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        The time before considering a healthcheck probing failed (seconds; must be between `2` and `60`; default: `3`).
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> Optional[bool]:
        """
        Disable TLS certificate verification for healthcheck in `https` mode (boolean; default: `false`).
        """
        return pulumi.get(self, "tls_skip_verify")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> Optional[str]:
        """
        The healthcheck server name to present with SNI in `https` mode.
        """
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        The healthcheck target URI (required in `http(s)` modes).
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class IAMAPIKeyTimeouts(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        IAMAPIKeyTimeouts._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            read=read,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             read: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if read is not None:
            _setter("read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class IAMOrgPolicyServices(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.IAMOrgPolicyServicesRule']] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['IAMOrgPolicyServicesRuleArgs'] rules: List of IAM service rules (if type is `rules`).
        :param str type: Service type (`rules`, `allow`, or `deny`).
        """
        IAMOrgPolicyServices._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[Sequence['outputs.IAMOrgPolicyServicesRule']] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if rules is not None:
            _setter("rules", rules)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.IAMOrgPolicyServicesRule']]:
        """
        List of IAM service rules (if type is `rules`).
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Service type (`rules`, `allow`, or `deny`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class IAMOrgPolicyServicesRule(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 expression: Optional[str] = None,
                 resources: Optional[Sequence[str]] = None):
        """
        :param str action: IAM policy rule action (`allow` or `deny`).
        :param str expression: IAM policy rule expression.
        :param Sequence[str] resources: List of resources that IAM policy rule applies to.
        """
        IAMOrgPolicyServicesRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            expression=expression,
            resources=resources,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             expression: Optional[str] = None,
             resources: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if action is not None:
            _setter("action", action)
        if expression is not None:
            _setter("expression", expression)
        if resources is not None:
            _setter("resources", resources)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        IAM policy rule action (`allow` or `deny`).
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        IAM policy rule expression.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[str]]:
        """
        List of resources that IAM policy rule applies to.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class IAMOrgPolicyTimeouts(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        IAMOrgPolicyTimeouts._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            read=read,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             read: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if read is not None:
            _setter("read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class IAMRolePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultServiceStrategy":
            suggest = "default_service_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IAMRolePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IAMRolePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IAMRolePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_service_strategy: Optional[str] = None,
                 services: Optional[Mapping[str, 'outputs.IAMRolePolicyServices']] = None):
        """
        :param str default_service_strategy: Default service strategy (`allow` or `deny`).
        :param Mapping[str, 'IAMRolePolicyServicesArgs'] services: IAM policy services.
        """
        IAMRolePolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_service_strategy=default_service_strategy,
            services=services,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_service_strategy: Optional[str] = None,
             services: Optional[Mapping[str, 'outputs.IAMRolePolicyServices']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if default_service_strategy is not None:
            _setter("default_service_strategy", default_service_strategy)
        if services is not None:
            _setter("services", services)

    @property
    @pulumi.getter(name="defaultServiceStrategy")
    def default_service_strategy(self) -> Optional[str]:
        """
        Default service strategy (`allow` or `deny`).
        """
        return pulumi.get(self, "default_service_strategy")

    @property
    @pulumi.getter
    def services(self) -> Optional[Mapping[str, 'outputs.IAMRolePolicyServices']]:
        """
        IAM policy services.
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class IAMRolePolicyServices(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.IAMRolePolicyServicesRule']] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['IAMRolePolicyServicesRuleArgs'] rules: List of IAM service rules (if type is `rules`).
        :param str type: Service type (`rules`, `allow`, or `deny`).
        """
        IAMRolePolicyServices._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Optional[Sequence['outputs.IAMRolePolicyServicesRule']] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if rules is not None:
            _setter("rules", rules)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.IAMRolePolicyServicesRule']]:
        """
        List of IAM service rules (if type is `rules`).
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Service type (`rules`, `allow`, or `deny`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class IAMRolePolicyServicesRule(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 expression: Optional[str] = None,
                 resources: Optional[Sequence[str]] = None):
        """
        :param str action: IAM policy rule action (`allow` or `deny`).
        :param str expression: IAM policy rule expression.
        :param Sequence[str] resources: List of resources that IAM policy rule applies to.
        """
        IAMRolePolicyServicesRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            expression=expression,
            resources=resources,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: Optional[str] = None,
             expression: Optional[str] = None,
             resources: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if action is not None:
            _setter("action", action)
        if expression is not None:
            _setter("expression", expression)
        if resources is not None:
            _setter("resources", resources)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        IAM policy rule action (`allow` or `deny`).
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        IAM policy rule expression.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[str]]:
        """
        List of resources that IAM policy rule applies to.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class IAMRoleTimeouts(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        IAMRoleTimeouts._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            read=read,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             read: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if read is not None:
            _setter("read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class InstancePoolInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"
        elif key == "publicIpAddress":
            suggest = "public_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePoolInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePoolInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePoolInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 ipv6_address: Optional[str] = None,
                 name: Optional[str] = None,
                 public_ip_address: Optional[str] = None):
        """
        :param str id: The ID of this resource.
        :param str ipv6_address: The instance (main network interface) IPv6 address.
        :param str name: The instance name.
        :param str public_ip_address: The instance (main network interface) IPv4 address.
        """
        InstancePoolInstance._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            ipv6_address=ipv6_address,
            name=name,
            public_ip_address=public_ip_address,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             ipv6_address: Optional[str] = None,
             name: Optional[str] = None,
             public_ip_address: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if ipv6_address is not None:
            _setter("ipv6_address", ipv6_address)
        if name is not None:
            _setter("name", name)
        if public_ip_address is not None:
            _setter("public_ip_address", public_ip_address)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[str]:
        """
        The instance (main network interface) IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The instance name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> Optional[str]:
        """
        The instance (main network interface) IPv4 address.
        """
        return pulumi.get(self, "public_ip_address")


@pulumi.output_type
class NLBServiceHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tlsSni":
            suggest = "tls_sni"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NLBServiceHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NLBServiceHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NLBServiceHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: int,
                 interval: Optional[int] = None,
                 mode: Optional[str] = None,
                 retries: Optional[int] = None,
                 timeout: Optional[int] = None,
                 tls_sni: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        :param int port: The NLB service (TCP/UDP) port.
        :param int interval: The healthcheck interval in seconds (default: `10`).
        :param str mode: The healthcheck mode (`tcp`|`http`|`https`; default: `tcp`).
        :param int retries: The healthcheck retries (default: `1`).
        :param int timeout: The healthcheck timeout (seconds; default: `5`).
        :param str tls_sni: The healthcheck TLS SNI server name (only if `mode` is `https`).
        :param str uri: The healthcheck URI (must be set only if `mode` is `http(s)`).
        """
        NLBServiceHealthcheck._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port=port,
            interval=interval,
            mode=mode,
            retries=retries,
            timeout=timeout,
            tls_sni=tls_sni,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port: int,
             interval: Optional[int] = None,
             mode: Optional[str] = None,
             retries: Optional[int] = None,
             timeout: Optional[int] = None,
             tls_sni: Optional[str] = None,
             uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("port", port)
        if interval is not None:
            _setter("interval", interval)
        if mode is not None:
            _setter("mode", mode)
        if retries is not None:
            _setter("retries", retries)
        if timeout is not None:
            _setter("timeout", timeout)
        if tls_sni is not None:
            _setter("tls_sni", tls_sni)
        if uri is not None:
            _setter("uri", uri)

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The NLB service (TCP/UDP) port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        The healthcheck interval in seconds (default: `10`).
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        The healthcheck mode (`tcp`|`http`|`https`; default: `tcp`).
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def retries(self) -> Optional[int]:
        """
        The healthcheck retries (default: `1`).
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        The healthcheck timeout (seconds; default: `5`).
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> Optional[str]:
        """
        The healthcheck TLS SNI server name (only if `mode` is `https`).
        """
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        """
        The healthcheck URI (must be set only if `mode` is `http(s)`).
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class SKSClusterOidc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "issuerUrl":
            suggest = "issuer_url"
        elif key == "groupsClaim":
            suggest = "groups_claim"
        elif key == "groupsPrefix":
            suggest = "groups_prefix"
        elif key == "requiredClaim":
            suggest = "required_claim"
        elif key == "usernameClaim":
            suggest = "username_claim"
        elif key == "usernamePrefix":
            suggest = "username_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SKSClusterOidc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SKSClusterOidc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SKSClusterOidc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 issuer_url: str,
                 groups_claim: Optional[str] = None,
                 groups_prefix: Optional[str] = None,
                 required_claim: Optional[Mapping[str, str]] = None,
                 username_claim: Optional[str] = None,
                 username_prefix: Optional[str] = None):
        """
        :param str client_id: The OpenID client ID.
        :param str issuer_url: The OpenID provider URL.
        :param str groups_claim: An OpenID JWT claim to use as the user's group.
        :param str groups_prefix: An OpenID prefix prepended to group claims.
        :param Mapping[str, str] required_claim: A map of key/value pairs that describes a required claim in the OpenID Token.
        :param str username_claim: An OpenID JWT claim to use as the user name.
        :param str username_prefix: An OpenID prefix prepended to username claims.
        """
        SKSClusterOidc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            issuer_url=issuer_url,
            groups_claim=groups_claim,
            groups_prefix=groups_prefix,
            required_claim=required_claim,
            username_claim=username_claim,
            username_prefix=username_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: str,
             issuer_url: str,
             groups_claim: Optional[str] = None,
             groups_prefix: Optional[str] = None,
             required_claim: Optional[Mapping[str, str]] = None,
             username_claim: Optional[str] = None,
             username_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("client_id", client_id)
        _setter("issuer_url", issuer_url)
        if groups_claim is not None:
            _setter("groups_claim", groups_claim)
        if groups_prefix is not None:
            _setter("groups_prefix", groups_prefix)
        if required_claim is not None:
            _setter("required_claim", required_claim)
        if username_claim is not None:
            _setter("username_claim", username_claim)
        if username_prefix is not None:
            _setter("username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        """
        The OpenID provider URL.
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[str]:
        """
        An OpenID JWT claim to use as the user's group.
        """
        return pulumi.get(self, "groups_claim")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[str]:
        """
        An OpenID prefix prepended to group claims.
        """
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[Mapping[str, str]]:
        """
        A map of key/value pairs that describes a required claim in the OpenID Token.
        """
        return pulumi.get(self, "required_claim")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[str]:
        """
        An OpenID JWT claim to use as the user name.
        """
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[str]:
        """
        An OpenID prefix prepended to username claims.
        """
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class SecurityGroupRulesEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrLists":
            suggest = "cidr_lists"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "userSecurityGroupLists":
            suggest = "user_security_group_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupRulesEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupRulesEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupRulesEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_lists: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 icmp_code: Optional[int] = None,
                 icmp_type: Optional[int] = None,
                 ids: Optional[Sequence[str]] = None,
                 ports: Optional[Sequence[str]] = None,
                 protocol: Optional[str] = None,
                 user_security_group_lists: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] cidr_lists: A list of (`INGRESS`) source / (`EGRESS`) destination IP subnet (in CIDR notation) to match.
        :param str description: A free-form text describing the block.
        :param int icmp_code: An ICMP/ICMPv6 type/code to match.
        :param int icmp_type: An ICMP/ICMPv6 type/code to match.
        :param Sequence[str] ports: A list of ports or port ranges (`<start_port>-<end_port>`).
        :param str protocol: The network protocol to match (`TCP`, `UDP`, `ICMP`, `ICMPv6`, `AH`, `ESP`, `GRE`, `IPIP` or `ALL`).
        :param Sequence[str] user_security_group_lists: A list of source (for ingress)/destination (for egress) identified by a security group.
        """
        SecurityGroupRulesEgress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr_lists=cidr_lists,
            description=description,
            icmp_code=icmp_code,
            icmp_type=icmp_type,
            ids=ids,
            ports=ports,
            protocol=protocol,
            user_security_group_lists=user_security_group_lists,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr_lists: Optional[Sequence[str]] = None,
             description: Optional[str] = None,
             icmp_code: Optional[int] = None,
             icmp_type: Optional[int] = None,
             ids: Optional[Sequence[str]] = None,
             ports: Optional[Sequence[str]] = None,
             protocol: Optional[str] = None,
             user_security_group_lists: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cidr_lists is not None:
            _setter("cidr_lists", cidr_lists)
        if description is not None:
            _setter("description", description)
        if icmp_code is not None:
            _setter("icmp_code", icmp_code)
        if icmp_type is not None:
            _setter("icmp_type", icmp_type)
        if ids is not None:
            _setter("ids", ids)
        if ports is not None:
            _setter("ports", ports)
        if protocol is not None:
            _setter("protocol", protocol)
        if user_security_group_lists is not None:
            _setter("user_security_group_lists", user_security_group_lists)

    @property
    @pulumi.getter(name="cidrLists")
    def cidr_lists(self) -> Optional[Sequence[str]]:
        """
        A list of (`INGRESS`) source / (`EGRESS`) destination IP subnet (in CIDR notation) to match.
        """
        return pulumi.get(self, "cidr_lists")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A free-form text describing the block.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[int]:
        """
        An ICMP/ICMPv6 type/code to match.
        """
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[int]:
        """
        An ICMP/ICMPv6 type/code to match.
        """
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ids")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        A list of ports or port ranges (`<start_port>-<end_port>`).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The network protocol to match (`TCP`, `UDP`, `ICMP`, `ICMPv6`, `AH`, `ESP`, `GRE`, `IPIP` or `ALL`).
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="userSecurityGroupLists")
    def user_security_group_lists(self) -> Optional[Sequence[str]]:
        """
        A list of source (for ingress)/destination (for egress) identified by a security group.
        """
        return pulumi.get(self, "user_security_group_lists")


@pulumi.output_type
class SecurityGroupRulesIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrLists":
            suggest = "cidr_lists"
        elif key == "icmpCode":
            suggest = "icmp_code"
        elif key == "icmpType":
            suggest = "icmp_type"
        elif key == "userSecurityGroupLists":
            suggest = "user_security_group_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupRulesIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupRulesIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupRulesIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_lists: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 icmp_code: Optional[int] = None,
                 icmp_type: Optional[int] = None,
                 ids: Optional[Sequence[str]] = None,
                 ports: Optional[Sequence[str]] = None,
                 protocol: Optional[str] = None,
                 user_security_group_lists: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] cidr_lists: A list of (`INGRESS`) source / (`EGRESS`) destination IP subnet (in CIDR notation) to match.
        :param str description: A free-form text describing the block.
        :param int icmp_code: An ICMP/ICMPv6 type/code to match.
        :param int icmp_type: An ICMP/ICMPv6 type/code to match.
        :param Sequence[str] ports: A list of ports or port ranges (`<start_port>-<end_port>`).
        :param str protocol: The network protocol to match (`TCP`, `UDP`, `ICMP`, `ICMPv6`, `AH`, `ESP`, `GRE`, `IPIP` or `ALL`).
        :param Sequence[str] user_security_group_lists: A list of source (for ingress)/destination (for egress) identified by a security group.
        """
        SecurityGroupRulesIngress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr_lists=cidr_lists,
            description=description,
            icmp_code=icmp_code,
            icmp_type=icmp_type,
            ids=ids,
            ports=ports,
            protocol=protocol,
            user_security_group_lists=user_security_group_lists,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr_lists: Optional[Sequence[str]] = None,
             description: Optional[str] = None,
             icmp_code: Optional[int] = None,
             icmp_type: Optional[int] = None,
             ids: Optional[Sequence[str]] = None,
             ports: Optional[Sequence[str]] = None,
             protocol: Optional[str] = None,
             user_security_group_lists: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cidr_lists is not None:
            _setter("cidr_lists", cidr_lists)
        if description is not None:
            _setter("description", description)
        if icmp_code is not None:
            _setter("icmp_code", icmp_code)
        if icmp_type is not None:
            _setter("icmp_type", icmp_type)
        if ids is not None:
            _setter("ids", ids)
        if ports is not None:
            _setter("ports", ports)
        if protocol is not None:
            _setter("protocol", protocol)
        if user_security_group_lists is not None:
            _setter("user_security_group_lists", user_security_group_lists)

    @property
    @pulumi.getter(name="cidrLists")
    def cidr_lists(self) -> Optional[Sequence[str]]:
        """
        A list of (`INGRESS`) source / (`EGRESS`) destination IP subnet (in CIDR notation) to match.
        """
        return pulumi.get(self, "cidr_lists")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A free-form text describing the block.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[int]:
        """
        An ICMP/ICMPv6 type/code to match.
        """
        return pulumi.get(self, "icmp_code")

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[int]:
        """
        An ICMP/ICMPv6 type/code to match.
        """
        return pulumi.get(self, "icmp_type")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ids")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        A list of ports or port ranges (`<start_port>-<end_port>`).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The network protocol to match (`TCP`, `UDP`, `ICMP`, `ICMPv6`, `AH`, `ESP`, `GRE`, `IPIP` or `ALL`).
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="userSecurityGroupLists")
    def user_security_group_lists(self) -> Optional[Sequence[str]]:
        """
        A list of source (for ingress)/destination (for egress) identified by a security group.
        """
        return pulumi.get(self, "user_security_group_lists")


@pulumi.output_type
class GetComputeInstanceListInstanceResult(dict):
    def __init__(__self__, *,
                 anti_affinity_group_ids: Sequence[str],
                 created_at: str,
                 deploy_target_id: str,
                 disk_size: int,
                 elastic_ip_ids: Sequence[str],
                 ipv6: bool,
                 ipv6_address: str,
                 labels: Mapping[str, str],
                 manager_id: str,
                 manager_type: str,
                 private_network_ids: Sequence[str],
                 public_ip_address: str,
                 reverse_dns: str,
                 security_group_ids: Sequence[str],
                 ssh_key: str,
                 state: str,
                 template_id: str,
                 type: str,
                 user_data: str,
                 zone: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        GetComputeInstanceListInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            anti_affinity_group_ids=anti_affinity_group_ids,
            created_at=created_at,
            deploy_target_id=deploy_target_id,
            disk_size=disk_size,
            elastic_ip_ids=elastic_ip_ids,
            ipv6=ipv6,
            ipv6_address=ipv6_address,
            labels=labels,
            manager_id=manager_id,
            manager_type=manager_type,
            private_network_ids=private_network_ids,
            public_ip_address=public_ip_address,
            reverse_dns=reverse_dns,
            security_group_ids=security_group_ids,
            ssh_key=ssh_key,
            state=state,
            template_id=template_id,
            type=type,
            user_data=user_data,
            zone=zone,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             anti_affinity_group_ids: Sequence[str],
             created_at: str,
             deploy_target_id: str,
             disk_size: int,
             elastic_ip_ids: Sequence[str],
             ipv6: bool,
             ipv6_address: str,
             labels: Mapping[str, str],
             manager_id: str,
             manager_type: str,
             private_network_ids: Sequence[str],
             public_ip_address: str,
             reverse_dns: str,
             security_group_ids: Sequence[str],
             ssh_key: str,
             state: str,
             template_id: str,
             type: str,
             user_data: str,
             zone: str,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("anti_affinity_group_ids", anti_affinity_group_ids)
        _setter("created_at", created_at)
        _setter("deploy_target_id", deploy_target_id)
        _setter("disk_size", disk_size)
        _setter("elastic_ip_ids", elastic_ip_ids)
        _setter("ipv6", ipv6)
        _setter("ipv6_address", ipv6_address)
        _setter("labels", labels)
        _setter("manager_id", manager_id)
        _setter("manager_type", manager_type)
        _setter("private_network_ids", private_network_ids)
        _setter("public_ip_address", public_ip_address)
        _setter("reverse_dns", reverse_dns)
        _setter("security_group_ids", security_group_ids)
        _setter("ssh_key", ssh_key)
        _setter("state", state)
        _setter("template_id", template_id)
        _setter("type", type)
        _setter("user_data", user_data)
        _setter("zone", zone)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="antiAffinityGroupIds")
    def anti_affinity_group_ids(self) -> Sequence[str]:
        return pulumi.get(self, "anti_affinity_group_ids")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="deployTargetId")
    def deploy_target_id(self) -> str:
        return pulumi.get(self, "deploy_target_id")

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="elasticIpIds")
    def elastic_ip_ids(self) -> Sequence[str]:
        return pulumi.get(self, "elastic_ip_ids")

    @property
    @pulumi.getter
    def ipv6(self) -> bool:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="managerId")
    def manager_id(self) -> str:
        return pulumi.get(self, "manager_id")

    @property
    @pulumi.getter(name="managerType")
    def manager_type(self) -> str:
        return pulumi.get(self, "manager_type")

    @property
    @pulumi.getter(name="privateNetworkIds")
    def private_network_ids(self) -> Sequence[str]:
        return pulumi.get(self, "private_network_ids")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter(name="reverseDns")
    def reverse_dns(self) -> str:
        return pulumi.get(self, "reverse_dns")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> str:
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> str:
        return pulumi.get(self, "user_data")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDatabaseURITimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        GetDatabaseURITimeoutsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            read=read,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             read: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if read is not None:
            _setter("read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetDomainRecordFilterResult(dict):
    def __init__(__self__, *,
                 content_regex: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 record_type: Optional[str] = None):
        """
        :param str content_regex: A regular expression to match the record content.
        :param str id: The record ID to match.
        :param str name: The domain record name to match.
        :param str record_type: The record type to match.
        """
        GetDomainRecordFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content_regex=content_regex,
            id=id,
            name=name,
            record_type=record_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content_regex: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             record_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if content_regex is not None:
            _setter("content_regex", content_regex)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if record_type is not None:
            _setter("record_type", record_type)

    @property
    @pulumi.getter(name="contentRegex")
    def content_regex(self) -> Optional[str]:
        """
        A regular expression to match the record content.
        """
        return pulumi.get(self, "content_regex")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The record ID to match.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The domain record name to match.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[str]:
        """
        The record type to match.
        """
        return pulumi.get(self, "record_type")


@pulumi.output_type
class GetDomainRecordRecordResult(dict):
    def __init__(__self__, *,
                 content: Optional[str] = None,
                 domain: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 prio: Optional[int] = None,
                 record_type: Optional[str] = None,
                 ttl: Optional[int] = None):
        GetDomainRecordRecordResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            domain=domain,
            id=id,
            name=name,
            prio=prio,
            record_type=record_type,
            ttl=ttl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: Optional[str] = None,
             domain: Optional[str] = None,
             id: Optional[str] = None,
             name: Optional[str] = None,
             prio: Optional[int] = None,
             record_type: Optional[str] = None,
             ttl: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if content is not None:
            _setter("content", content)
        if domain is not None:
            _setter("domain", domain)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if prio is not None:
            _setter("prio", prio)
        if record_type is not None:
            _setter("record_type", record_type)
        if ttl is not None:
            _setter("ttl", ttl)

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prio(self) -> Optional[int]:
        return pulumi.get(self, "prio")

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[str]:
        return pulumi.get(self, "record_type")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetElasticIPHealthcheckResult(dict):
    def __init__(__self__, *,
                 interval: int,
                 mode: str,
                 port: int,
                 strikes_fail: int,
                 strikes_ok: int,
                 timeout: int,
                 tls_skip_verify: bool,
                 tls_sni: str,
                 uri: str):
        GetElasticIPHealthcheckResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            interval=interval,
            mode=mode,
            port=port,
            strikes_fail=strikes_fail,
            strikes_ok=strikes_ok,
            timeout=timeout,
            tls_skip_verify=tls_skip_verify,
            tls_sni=tls_sni,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             interval: int,
             mode: str,
             port: int,
             strikes_fail: int,
             strikes_ok: int,
             timeout: int,
             tls_skip_verify: bool,
             tls_sni: str,
             uri: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("interval", interval)
        _setter("mode", mode)
        _setter("port", port)
        _setter("strikes_fail", strikes_fail)
        _setter("strikes_ok", strikes_ok)
        _setter("timeout", timeout)
        _setter("tls_skip_verify", tls_skip_verify)
        _setter("tls_sni", tls_sni)
        _setter("uri", uri)

    @property
    @pulumi.getter
    def interval(self) -> int:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="strikesFail")
    def strikes_fail(self) -> int:
        return pulumi.get(self, "strikes_fail")

    @property
    @pulumi.getter(name="strikesOk")
    def strikes_ok(self) -> int:
        return pulumi.get(self, "strikes_ok")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> bool:
        return pulumi.get(self, "tls_skip_verify")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> str:
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> str:
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetIAMAPIKeyTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        GetIAMAPIKeyTimeoutsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            read=read,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             read: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if read is not None:
            _setter("read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetIAMOrgPolicyServicesResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetIAMOrgPolicyServicesRuleResult'],
                 type: str):
        """
        :param Sequence['GetIAMOrgPolicyServicesRuleArgs'] rules: List of IAM service rules (if type is `rules`).
        :param str type: Service type (`rules`, `allow`, or `deny`).
        """
        GetIAMOrgPolicyServicesResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Sequence['outputs.GetIAMOrgPolicyServicesRuleResult'],
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("rules", rules)
        _setter("type", type)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetIAMOrgPolicyServicesRuleResult']:
        """
        List of IAM service rules (if type is `rules`).
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Service type (`rules`, `allow`, or `deny`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetIAMOrgPolicyServicesRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 expression: str,
                 resources: Sequence[str]):
        """
        :param str action: IAM policy rule action (`allow` or `deny`).
        :param str expression: IAM policy rule expression.
        :param Sequence[str] resources: List of resources that IAM policy rule applies to.
        """
        GetIAMOrgPolicyServicesRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            expression=expression,
            resources=resources,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             expression: str,
             resources: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("expression", expression)
        _setter("resources", resources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        IAM policy rule action (`allow` or `deny`).
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        IAM policy rule expression.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def resources(self) -> Sequence[str]:
        """
        List of resources that IAM policy rule applies to.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetIAMOrgPolicyTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        GetIAMOrgPolicyTimeoutsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            read=read,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             read: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if read is not None:
            _setter("read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetIAMRolePolicyResult(dict):
    def __init__(__self__, *,
                 default_service_strategy: str,
                 services: Mapping[str, 'outputs.GetIAMRolePolicyServicesResult']):
        """
        :param str default_service_strategy: Default service strategy (`allow` or `deny`).
        :param Mapping[str, 'GetIAMRolePolicyServicesArgs'] services: IAM policy services.
        """
        GetIAMRolePolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_service_strategy=default_service_strategy,
            services=services,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_service_strategy: str,
             services: Mapping[str, 'outputs.GetIAMRolePolicyServicesResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_service_strategy", default_service_strategy)
        _setter("services", services)

    @property
    @pulumi.getter(name="defaultServiceStrategy")
    def default_service_strategy(self) -> str:
        """
        Default service strategy (`allow` or `deny`).
        """
        return pulumi.get(self, "default_service_strategy")

    @property
    @pulumi.getter
    def services(self) -> Mapping[str, 'outputs.GetIAMRolePolicyServicesResult']:
        """
        IAM policy services.
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class GetIAMRolePolicyServicesResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetIAMRolePolicyServicesRuleResult'],
                 type: str):
        """
        :param Sequence['GetIAMRolePolicyServicesRuleArgs'] rules: List of IAM service rules (if type is `rules`).
        :param str type: Service type (`rules`, `allow`, or `deny`).
        """
        GetIAMRolePolicyServicesResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: Sequence['outputs.GetIAMRolePolicyServicesRuleResult'],
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("rules", rules)
        _setter("type", type)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetIAMRolePolicyServicesRuleResult']:
        """
        List of IAM service rules (if type is `rules`).
        """
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Service type (`rules`, `allow`, or `deny`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetIAMRolePolicyServicesRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 expression: str,
                 resources: Sequence[str]):
        """
        :param str action: IAM policy rule action (`allow` or `deny`).
        :param str expression: IAM policy rule expression.
        :param Sequence[str] resources: List of resources that IAM policy rule applies to.
        """
        GetIAMRolePolicyServicesRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            expression=expression,
            resources=resources,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             expression: str,
             resources: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("expression", expression)
        _setter("resources", resources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        IAM policy rule action (`allow` or `deny`).
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        IAM policy rule expression.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def resources(self) -> Sequence[str]:
        """
        List of resources that IAM policy rule applies to.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetIAMRoleTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        GetIAMRoleTimeoutsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            read=read,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             read: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if read is not None:
            _setter("read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetInstancePoolInstanceResult(dict):
    def __init__(__self__, *,
                 ipv6_address: str,
                 public_ip_address: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        GetInstancePoolInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv6_address=ipv6_address,
            public_ip_address=public_ip_address,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv6_address: str,
             public_ip_address: str,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ipv6_address", ipv6_address)
        _setter("public_ip_address", public_ip_address)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstancePoolListPoolResult(dict):
    def __init__(__self__, *,
                 affinity_group_ids: Sequence[str],
                 deploy_target_id: str,
                 description: str,
                 disk_size: int,
                 elastic_ip_ids: Sequence[str],
                 instance_prefix: str,
                 instance_type: str,
                 instances: Sequence['outputs.GetInstancePoolListPoolInstanceResult'],
                 ipv6: bool,
                 key_pair: str,
                 network_ids: Sequence[str],
                 security_group_ids: Sequence[str],
                 size: int,
                 state: str,
                 template_id: str,
                 user_data: str,
                 zone: str,
                 id: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None):
        GetInstancePoolListPoolResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            affinity_group_ids=affinity_group_ids,
            deploy_target_id=deploy_target_id,
            description=description,
            disk_size=disk_size,
            elastic_ip_ids=elastic_ip_ids,
            instance_prefix=instance_prefix,
            instance_type=instance_type,
            instances=instances,
            ipv6=ipv6,
            key_pair=key_pair,
            network_ids=network_ids,
            security_group_ids=security_group_ids,
            size=size,
            state=state,
            template_id=template_id,
            user_data=user_data,
            zone=zone,
            id=id,
            labels=labels,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             affinity_group_ids: Sequence[str],
             deploy_target_id: str,
             description: str,
             disk_size: int,
             elastic_ip_ids: Sequence[str],
             instance_prefix: str,
             instance_type: str,
             instances: Sequence['outputs.GetInstancePoolListPoolInstanceResult'],
             ipv6: bool,
             key_pair: str,
             network_ids: Sequence[str],
             security_group_ids: Sequence[str],
             size: int,
             state: str,
             template_id: str,
             user_data: str,
             zone: str,
             id: Optional[str] = None,
             labels: Optional[Mapping[str, str]] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("affinity_group_ids", affinity_group_ids)
        _setter("deploy_target_id", deploy_target_id)
        _setter("description", description)
        _setter("disk_size", disk_size)
        _setter("elastic_ip_ids", elastic_ip_ids)
        _setter("instance_prefix", instance_prefix)
        _setter("instance_type", instance_type)
        _setter("instances", instances)
        _setter("ipv6", ipv6)
        _setter("key_pair", key_pair)
        _setter("network_ids", network_ids)
        _setter("security_group_ids", security_group_ids)
        _setter("size", size)
        _setter("state", state)
        _setter("template_id", template_id)
        _setter("user_data", user_data)
        _setter("zone", zone)
        if id is not None:
            _setter("id", id)
        if labels is not None:
            _setter("labels", labels)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="affinityGroupIds")
    def affinity_group_ids(self) -> Sequence[str]:
        return pulumi.get(self, "affinity_group_ids")

    @property
    @pulumi.getter(name="deployTargetId")
    def deploy_target_id(self) -> str:
        return pulumi.get(self, "deploy_target_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> int:
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter(name="elasticIpIds")
    def elastic_ip_ids(self) -> Sequence[str]:
        return pulumi.get(self, "elastic_ip_ids")

    @property
    @pulumi.getter(name="instancePrefix")
    def instance_prefix(self) -> str:
        return pulumi.get(self, "instance_prefix")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GetInstancePoolListPoolInstanceResult']:
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter
    def ipv6(self) -> bool:
        return pulumi.get(self, "ipv6")

    @property
    @pulumi.getter(name="keyPair")
    def key_pair(self) -> str:
        return pulumi.get(self, "key_pair")

    @property
    @pulumi.getter(name="networkIds")
    def network_ids(self) -> Sequence[str]:
        return pulumi.get(self, "network_ids")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Sequence[str]:
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> str:
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> str:
        return pulumi.get(self, "user_data")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInstancePoolListPoolInstanceResult(dict):
    def __init__(__self__, *,
                 ipv6_address: str,
                 public_ip_address: str,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        GetInstancePoolListPoolInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ipv6_address=ipv6_address,
            public_ip_address=public_ip_address,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ipv6_address: str,
             public_ip_address: str,
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ipv6_address", ipv6_address)
        _setter("public_ip_address", public_ip_address)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="publicIpAddress")
    def public_ip_address(self) -> str:
        return pulumi.get(self, "public_ip_address")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNLBServiceListServiceResult(dict):
    def __init__(__self__, *,
                 description: str,
                 healthcheck: 'outputs.GetNLBServiceListServiceHealthcheckResult',
                 id: str,
                 instance_pool_id: str,
                 name: str,
                 port: int,
                 protocol: str,
                 state: str,
                 strategy: str,
                 target_port: int):
        """
        :param str description: NLB service description.
        :param str id: NLB service ID.
        :param str instance_pool_id: The exoscale*instance*pool (ID) to forward traffic to.
        :param str name: NLB Service name.
        :param int port: Port exposed on the NLB's public IP.
        :param str protocol: Network traffic protocol.
        :param str state: NLB Service State.
        :param str strategy: The strategy (`round-robin`|`source-hash`).
        :param int target_port: Port on which the network traffic will be forwarded to on the receiving instance.
        """
        GetNLBServiceListServiceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            healthcheck=healthcheck,
            id=id,
            instance_pool_id=instance_pool_id,
            name=name,
            port=port,
            protocol=protocol,
            state=state,
            strategy=strategy,
            target_port=target_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: str,
             healthcheck: 'outputs.GetNLBServiceListServiceHealthcheckResult',
             id: str,
             instance_pool_id: str,
             name: str,
             port: int,
             protocol: str,
             state: str,
             strategy: str,
             target_port: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("description", description)
        _setter("healthcheck", healthcheck)
        _setter("id", id)
        _setter("instance_pool_id", instance_pool_id)
        _setter("name", name)
        _setter("port", port)
        _setter("protocol", protocol)
        _setter("state", state)
        _setter("strategy", strategy)
        _setter("target_port", target_port)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        NLB service description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def healthcheck(self) -> 'outputs.GetNLBServiceListServiceHealthcheckResult':
        return pulumi.get(self, "healthcheck")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        NLB service ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> str:
        """
        The exoscale*instance*pool (ID) to forward traffic to.
        """
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        NLB Service name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port exposed on the NLB's public IP.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Network traffic protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        NLB Service State.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        """
        The strategy (`round-robin`|`source-hash`).
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> int:
        """
        Port on which the network traffic will be forwarded to on the receiving instance.
        """
        return pulumi.get(self, "target_port")


@pulumi.output_type
class GetNLBServiceListServiceHealthcheckResult(dict):
    def __init__(__self__, *,
                 interval: int,
                 mode: str,
                 port: int,
                 retries: int,
                 timeout: int,
                 tls_sni: str,
                 uri: str):
        GetNLBServiceListServiceHealthcheckResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            interval=interval,
            mode=mode,
            port=port,
            retries=retries,
            timeout=timeout,
            tls_sni=tls_sni,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             interval: int,
             mode: str,
             port: int,
             retries: int,
             timeout: int,
             tls_sni: str,
             uri: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("interval", interval)
        _setter("mode", mode)
        _setter("port", port)
        _setter("retries", retries)
        _setter("timeout", timeout)
        _setter("tls_sni", tls_sni)
        _setter("uri", uri)

    @property
    @pulumi.getter
    def interval(self) -> int:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def retries(self) -> int:
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def timeout(self) -> int:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsSni")
    def tls_sni(self) -> str:
        return pulumi.get(self, "tls_sni")

    @property
    @pulumi.getter
    def uri(self) -> str:
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetNLBServiceListTimeoutsResult(dict):
    def __init__(__self__, *,
                 read: Optional[str] = None):
        """
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        GetNLBServiceListTimeoutsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            read=read,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             read: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if read is not None:
            _setter("read", read)

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class GetSKSClusterListClusterResult(dict):
    def __init__(__self__, *,
                 addons: Sequence[str],
                 aggregation_ca: str,
                 control_plane_ca: str,
                 created_at: str,
                 endpoint: str,
                 kubelet_ca: str,
                 nodepools: Sequence[str],
                 oidc: 'outputs.GetSKSClusterListClusterOidcResult',
                 state: str,
                 version: str,
                 zone: str,
                 auto_upgrade: Optional[bool] = None,
                 cni: Optional[str] = None,
                 description: Optional[str] = None,
                 exoscale_ccm: Optional[bool] = None,
                 id: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 metrics_server: Optional[bool] = None,
                 name: Optional[str] = None,
                 service_level: Optional[str] = None):
        GetSKSClusterListClusterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            addons=addons,
            aggregation_ca=aggregation_ca,
            control_plane_ca=control_plane_ca,
            created_at=created_at,
            endpoint=endpoint,
            kubelet_ca=kubelet_ca,
            nodepools=nodepools,
            oidc=oidc,
            state=state,
            version=version,
            zone=zone,
            auto_upgrade=auto_upgrade,
            cni=cni,
            description=description,
            exoscale_ccm=exoscale_ccm,
            id=id,
            labels=labels,
            metrics_server=metrics_server,
            name=name,
            service_level=service_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             addons: Sequence[str],
             aggregation_ca: str,
             control_plane_ca: str,
             created_at: str,
             endpoint: str,
             kubelet_ca: str,
             nodepools: Sequence[str],
             oidc: 'outputs.GetSKSClusterListClusterOidcResult',
             state: str,
             version: str,
             zone: str,
             auto_upgrade: Optional[bool] = None,
             cni: Optional[str] = None,
             description: Optional[str] = None,
             exoscale_ccm: Optional[bool] = None,
             id: Optional[str] = None,
             labels: Optional[Mapping[str, str]] = None,
             metrics_server: Optional[bool] = None,
             name: Optional[str] = None,
             service_level: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("addons", addons)
        _setter("aggregation_ca", aggregation_ca)
        _setter("control_plane_ca", control_plane_ca)
        _setter("created_at", created_at)
        _setter("endpoint", endpoint)
        _setter("kubelet_ca", kubelet_ca)
        _setter("nodepools", nodepools)
        _setter("oidc", oidc)
        _setter("state", state)
        _setter("version", version)
        _setter("zone", zone)
        if auto_upgrade is not None:
            _setter("auto_upgrade", auto_upgrade)
        if cni is not None:
            _setter("cni", cni)
        if description is not None:
            _setter("description", description)
        if exoscale_ccm is not None:
            _setter("exoscale_ccm", exoscale_ccm)
        if id is not None:
            _setter("id", id)
        if labels is not None:
            _setter("labels", labels)
        if metrics_server is not None:
            _setter("metrics_server", metrics_server)
        if name is not None:
            _setter("name", name)
        if service_level is not None:
            _setter("service_level", service_level)

    @property
    @pulumi.getter
    def addons(self) -> Sequence[str]:
        warnings.warn("""This attribute has been replaced by `exoscale_ccm`/`metrics_server` attributes, it will be removed in a future release.""", DeprecationWarning)
        pulumi.log.warn("""addons is deprecated: This attribute has been replaced by `exoscale_ccm`/`metrics_server` attributes, it will be removed in a future release.""")

        return pulumi.get(self, "addons")

    @property
    @pulumi.getter(name="aggregationCa")
    def aggregation_ca(self) -> str:
        return pulumi.get(self, "aggregation_ca")

    @property
    @pulumi.getter(name="controlPlaneCa")
    def control_plane_ca(self) -> str:
        return pulumi.get(self, "control_plane_ca")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="kubeletCa")
    def kubelet_ca(self) -> str:
        return pulumi.get(self, "kubelet_ca")

    @property
    @pulumi.getter
    def nodepools(self) -> Sequence[str]:
        return pulumi.get(self, "nodepools")

    @property
    @pulumi.getter
    def oidc(self) -> 'outputs.GetSKSClusterListClusterOidcResult':
        return pulumi.get(self, "oidc")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> Optional[bool]:
        return pulumi.get(self, "auto_upgrade")

    @property
    @pulumi.getter
    def cni(self) -> Optional[str]:
        return pulumi.get(self, "cni")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="exoscaleCcm")
    def exoscale_ccm(self) -> Optional[bool]:
        return pulumi.get(self, "exoscale_ccm")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="metricsServer")
    def metrics_server(self) -> Optional[bool]:
        return pulumi.get(self, "metrics_server")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceLevel")
    def service_level(self) -> Optional[str]:
        return pulumi.get(self, "service_level")


@pulumi.output_type
class GetSKSClusterListClusterOidcResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 issuer_url: str,
                 groups_claim: Optional[str] = None,
                 groups_prefix: Optional[str] = None,
                 required_claim: Optional[Mapping[str, str]] = None,
                 username_claim: Optional[str] = None,
                 username_prefix: Optional[str] = None):
        GetSKSClusterListClusterOidcResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            issuer_url=issuer_url,
            groups_claim=groups_claim,
            groups_prefix=groups_prefix,
            required_claim=required_claim,
            username_claim=username_claim,
            username_prefix=username_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: str,
             issuer_url: str,
             groups_claim: Optional[str] = None,
             groups_prefix: Optional[str] = None,
             required_claim: Optional[Mapping[str, str]] = None,
             username_claim: Optional[str] = None,
             username_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("client_id", client_id)
        _setter("issuer_url", issuer_url)
        if groups_claim is not None:
            _setter("groups_claim", groups_claim)
        if groups_prefix is not None:
            _setter("groups_prefix", groups_prefix)
        if required_claim is not None:
            _setter("required_claim", required_claim)
        if username_claim is not None:
            _setter("username_claim", username_claim)
        if username_prefix is not None:
            _setter("username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[str]:
        return pulumi.get(self, "groups_claim")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[str]:
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "required_claim")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[str]:
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[str]:
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class GetSKSClusterOidcResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 issuer_url: str,
                 groups_claim: Optional[str] = None,
                 groups_prefix: Optional[str] = None,
                 required_claim: Optional[Mapping[str, str]] = None,
                 username_claim: Optional[str] = None,
                 username_prefix: Optional[str] = None):
        """
        :param str client_id: The OpenID client ID.
        :param str issuer_url: The OpenID provider URL.
        :param str groups_claim: An OpenID JWT claim to use as the user's group.
        :param str groups_prefix: An OpenID prefix prepended to group claims.
        :param Mapping[str, str] required_claim: A map of key/value pairs that describes a required claim in the OpenID Token.
        :param str username_claim: An OpenID JWT claim to use as the user name.
        :param str username_prefix: An OpenID prefix prepended to username claims.
        """
        GetSKSClusterOidcResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            issuer_url=issuer_url,
            groups_claim=groups_claim,
            groups_prefix=groups_prefix,
            required_claim=required_claim,
            username_claim=username_claim,
            username_prefix=username_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: str,
             issuer_url: str,
             groups_claim: Optional[str] = None,
             groups_prefix: Optional[str] = None,
             required_claim: Optional[Mapping[str, str]] = None,
             username_claim: Optional[str] = None,
             username_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("client_id", client_id)
        _setter("issuer_url", issuer_url)
        if groups_claim is not None:
            _setter("groups_claim", groups_claim)
        if groups_prefix is not None:
            _setter("groups_prefix", groups_prefix)
        if required_claim is not None:
            _setter("required_claim", required_claim)
        if username_claim is not None:
            _setter("username_claim", username_claim)
        if username_prefix is not None:
            _setter("username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The OpenID client ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        """
        The OpenID provider URL.
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> Optional[str]:
        """
        An OpenID JWT claim to use as the user's group.
        """
        return pulumi.get(self, "groups_claim")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[str]:
        """
        An OpenID prefix prepended to group claims.
        """
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="requiredClaim")
    def required_claim(self) -> Optional[Mapping[str, str]]:
        """
        A map of key/value pairs that describes a required claim in the OpenID Token.
        """
        return pulumi.get(self, "required_claim")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[str]:
        """
        An OpenID JWT claim to use as the user name.
        """
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[str]:
        """
        An OpenID prefix prepended to username claims.
        """
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class GetSKSNodepoolListNodepoolResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 created_at: str,
                 instance_pool_id: str,
                 state: str,
                 template_id: str,
                 version: str,
                 zone: str,
                 anti_affinity_group_ids: Optional[Sequence[str]] = None,
                 deploy_target_id: Optional[str] = None,
                 description: Optional[str] = None,
                 disk_size: Optional[int] = None,
                 id: Optional[str] = None,
                 instance_prefix: Optional[str] = None,
                 instance_type: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 private_network_ids: Optional[Sequence[str]] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 size: Optional[int] = None,
                 storage_lvm: Optional[bool] = None,
                 taints: Optional[Mapping[str, str]] = None):
        GetSKSNodepoolListNodepoolResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_id=cluster_id,
            created_at=created_at,
            instance_pool_id=instance_pool_id,
            state=state,
            template_id=template_id,
            version=version,
            zone=zone,
            anti_affinity_group_ids=anti_affinity_group_ids,
            deploy_target_id=deploy_target_id,
            description=description,
            disk_size=disk_size,
            id=id,
            instance_prefix=instance_prefix,
            instance_type=instance_type,
            labels=labels,
            name=name,
            private_network_ids=private_network_ids,
            security_group_ids=security_group_ids,
            size=size,
            storage_lvm=storage_lvm,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_id: str,
             created_at: str,
             instance_pool_id: str,
             state: str,
             template_id: str,
             version: str,
             zone: str,
             anti_affinity_group_ids: Optional[Sequence[str]] = None,
             deploy_target_id: Optional[str] = None,
             description: Optional[str] = None,
             disk_size: Optional[int] = None,
             id: Optional[str] = None,
             instance_prefix: Optional[str] = None,
             instance_type: Optional[str] = None,
             labels: Optional[Mapping[str, str]] = None,
             name: Optional[str] = None,
             private_network_ids: Optional[Sequence[str]] = None,
             security_group_ids: Optional[Sequence[str]] = None,
             size: Optional[int] = None,
             storage_lvm: Optional[bool] = None,
             taints: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cluster_id", cluster_id)
        _setter("created_at", created_at)
        _setter("instance_pool_id", instance_pool_id)
        _setter("state", state)
        _setter("template_id", template_id)
        _setter("version", version)
        _setter("zone", zone)
        if anti_affinity_group_ids is not None:
            _setter("anti_affinity_group_ids", anti_affinity_group_ids)
        if deploy_target_id is not None:
            _setter("deploy_target_id", deploy_target_id)
        if description is not None:
            _setter("description", description)
        if disk_size is not None:
            _setter("disk_size", disk_size)
        if id is not None:
            _setter("id", id)
        if instance_prefix is not None:
            _setter("instance_prefix", instance_prefix)
        if instance_type is not None:
            _setter("instance_type", instance_type)
        if labels is not None:
            _setter("labels", labels)
        if name is not None:
            _setter("name", name)
        if private_network_ids is not None:
            _setter("private_network_ids", private_network_ids)
        if security_group_ids is not None:
            _setter("security_group_ids", security_group_ids)
        if size is not None:
            _setter("size", size)
        if storage_lvm is not None:
            _setter("storage_lvm", storage_lvm)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> str:
        return pulumi.get(self, "instance_pool_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> str:
        return pulumi.get(self, "template_id")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")

    @property
    @pulumi.getter(name="antiAffinityGroupIds")
    def anti_affinity_group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "anti_affinity_group_ids")

    @property
    @pulumi.getter(name="deployTargetId")
    def deploy_target_id(self) -> Optional[str]:
        return pulumi.get(self, "deploy_target_id")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[int]:
        return pulumi.get(self, "disk_size")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instancePrefix")
    def instance_prefix(self) -> Optional[str]:
        return pulumi.get(self, "instance_prefix")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privateNetworkIds")
    def private_network_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "private_network_ids")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="storageLvm")
    def storage_lvm(self) -> Optional[bool]:
        return pulumi.get(self, "storage_lvm")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "taints")


