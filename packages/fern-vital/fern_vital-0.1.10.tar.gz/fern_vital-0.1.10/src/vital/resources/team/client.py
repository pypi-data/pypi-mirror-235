# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.unprocessable_entity_error import UnprocessableEntityError
from ...types.api_key_in_db import ApiKeyInDb
from ...types.client_facing_team import ClientFacingTeam
from ...types.client_facing_user import ClientFacingUser
from ...types.http_validation_error import HttpValidationError
from ...types.physician_network_t import PhysicianNetworkT
from ...types.priority import Priority
from ...types.team_in_db import TeamInDb

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class TeamClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_team_config(self) -> typing.Dict[str, typing.Any]:
        """
        Post teams.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/team/link/config"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_team(self, team_id: str) -> ClientFacingTeam:
        """
        Get team.

        Parameters:
            - team_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClientFacingTeam, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_team(
        self,
        team_id: str,
        *,
        lab_tests_patient_communication_enabled: typing.Optional[bool] = OMIT,
        subscription_status: typing.Optional[str] = OMIT,
        logo_url: typing.Optional[str] = OMIT,
    ) -> TeamInDb:
        """
        Update team.

        Parameters:
            - team_id: str.

            - lab_tests_patient_communication_enabled: typing.Optional[bool].

            - subscription_status: typing.Optional[str].

            - logo_url: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if lab_tests_patient_communication_enabled is not OMIT:
            _request["lab_tests_patient_communication_enabled"] = lab_tests_patient_communication_enabled
        if subscription_status is not OMIT:
            _request["subscription_status"] = subscription_status
        if logo_url is not OMIT:
            _request["logo_url"] = logo_url
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TeamInDb, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_team_user_count(self, team_id: str) -> typing.Dict[str, typing.Any]:
        """
        Get the current user count for a team.

        Parameters:
            - team_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}/users/count"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def search_team_users_by_uuid_or_client_user_id(
        self, *, query_id: typing.Optional[str] = None
    ) -> typing.List[ClientFacingUser]:
        """
        Search team users by user_id

        Parameters:
            - query_id: typing.Optional[str].
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/team/users/search"),
            params=remove_none_from_dict({"query_id": query_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ClientFacingUser], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_api_key(self, team_id: str, *, label: str) -> ApiKeyInDb:
        """
        Create api key.

        Parameters:
            - team_id: str.

            - label: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}/apikey"),
            json=jsonable_encoder({"label": label}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ApiKeyInDb, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_api_keys_for_team(self, team_id: str) -> typing.List[ApiKeyInDb]:
        """
        Invalidate api key by key value.

        Parameters:
            - team_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}/apikeys"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ApiKeyInDb], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_api_key_label(self, team_id: str, api_key_id: str, *, label: str) -> ApiKeyInDb:
        """
        Update API key label.

        Parameters:
            - team_id: str.

            - api_key_id: str.

            - label: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}/apikey/{api_key_id}"),
            json=jsonable_encoder({"label": label}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ApiKeyInDb, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_api_key(self, team_id: str, api_key_id: str) -> ApiKeyInDb:
        """
        Invalidate api key by key value.

        Parameters:
            - team_id: str.

            - api_key_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}/apikey/{api_key_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ApiKeyInDb, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def rotate_api_key(self, team_id: str, api_key_id: str) -> ApiKeyInDb:
        """
        Deprecated. Rotate api key.

        Parameters:
            - team_id: str.

            - api_key_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}/apikey/{api_key_id}/rotate"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ApiKeyInDb, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_team(
        self,
        *,
        svix_app_id: typing.Optional[str] = OMIT,
        client_id: typing.Optional[str] = OMIT,
        client_secret: typing.Optional[str] = OMIT,
        api_key: typing.Optional[str] = OMIT,
        airtable_api_key: typing.Optional[str] = OMIT,
        airtable_base_id: typing.Optional[str] = OMIT,
        webhook_secret: typing.Optional[str] = OMIT,
        ff_wheel_enabled: typing.Optional[bool] = OMIT,
        ff_apple_mobile_app_enabled: typing.Optional[bool] = OMIT,
        lab_tests_patient_communication_enabled: typing.Optional[bool] = OMIT,
        lab_test_delegated_flow_enabled: typing.Optional[bool] = OMIT,
        physician_network: typing.Optional[PhysicianNetworkT] = OMIT,
        id: typing.Optional[str] = OMIT,
        name: str,
        subscription_status: typing.Optional[str] = OMIT,
    ) -> TeamInDb:
        """
        Create Team.

        Parameters:
            - svix_app_id: typing.Optional[str].

            - client_id: typing.Optional[str].

            - client_secret: typing.Optional[str].

            - api_key: typing.Optional[str].

            - airtable_api_key: typing.Optional[str].

            - airtable_base_id: typing.Optional[str].

            - webhook_secret: typing.Optional[str].

            - ff_wheel_enabled: typing.Optional[bool].

            - ff_apple_mobile_app_enabled: typing.Optional[bool].

            - lab_tests_patient_communication_enabled: typing.Optional[bool].

            - lab_test_delegated_flow_enabled: typing.Optional[bool].

            - physician_network: typing.Optional[PhysicianNetworkT].

            - id: typing.Optional[str].

            - name: str.

            - subscription_status: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {"name": name}
        if svix_app_id is not OMIT:
            _request["svix_app_id"] = svix_app_id
        if client_id is not OMIT:
            _request["client_id"] = client_id
        if client_secret is not OMIT:
            _request["client_secret"] = client_secret
        if api_key is not OMIT:
            _request["api_key"] = api_key
        if airtable_api_key is not OMIT:
            _request["airtable_api_key"] = airtable_api_key
        if airtable_base_id is not OMIT:
            _request["airtable_base_id"] = airtable_base_id
        if webhook_secret is not OMIT:
            _request["webhook_secret"] = webhook_secret
        if ff_wheel_enabled is not OMIT:
            _request["ff_wheel_enabled"] = ff_wheel_enabled
        if ff_apple_mobile_app_enabled is not OMIT:
            _request["ff_apple_mobile_app_enabled"] = ff_apple_mobile_app_enabled
        if lab_tests_patient_communication_enabled is not OMIT:
            _request["lab_tests_patient_communication_enabled"] = lab_tests_patient_communication_enabled
        if lab_test_delegated_flow_enabled is not OMIT:
            _request["lab_test_delegated_flow_enabled"] = lab_test_delegated_flow_enabled
        if physician_network is not OMIT:
            _request["physician_network"] = physician_network
        if id is not OMIT:
            _request["id"] = id
        if subscription_status is not OMIT:
            _request["subscription_status"] = subscription_status
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/team"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TeamInDb, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_priority(
        self,
        team_id: str,
        *,
        id: typing.Optional[int] = OMIT,
        priority: int,
        priority_create_team_id: str,
        source_id: int,
        data_type: typing.Optional[str] = OMIT,
    ) -> Priority:
        """
        Add Team priority row for source

        Parameters:
            - team_id: str.

            - id: typing.Optional[int].

            - priority: int.

            - priority_create_team_id: str.

            - source_id: int.

            - data_type: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {
            "priority": priority,
            "team_id": priority_create_team_id,
            "source_id": source_id,
        }
        if id is not OMIT:
            _request["id"] = id
        if data_type is not OMIT:
            _request["data_type"] = data_type
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}/priority"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Priority, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_svix_webhook_url(self) -> typing.Dict[str, typing.Any]:
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/team/svix/url"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_source_priorities(
        self, *, data_type: typing.Optional[str] = None
    ) -> typing.List[typing.Dict[str, typing.Any]]:
        """
        GET source priorities.

        Parameters:
            - data_type: typing.Optional[str].
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/team/source/priorities"),
            params=remove_none_from_dict({"data_type": data_type}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[typing.Dict[str, typing.Any]], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_source_priorities(self, *, team_id: str) -> typing.List[typing.Dict[str, typing.Any]]:
        """
        Patch source priorities.

        Parameters:
            - team_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/team/source/priorities"),
            params=remove_none_from_dict({"team_id": team_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[typing.Dict[str, typing.Any]], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncTeamClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_team_config(self) -> typing.Dict[str, typing.Any]:
        """
        Post teams.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/team/link/config"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_team(self, team_id: str) -> ClientFacingTeam:
        """
        Get team.

        Parameters:
            - team_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClientFacingTeam, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_team(
        self,
        team_id: str,
        *,
        lab_tests_patient_communication_enabled: typing.Optional[bool] = OMIT,
        subscription_status: typing.Optional[str] = OMIT,
        logo_url: typing.Optional[str] = OMIT,
    ) -> TeamInDb:
        """
        Update team.

        Parameters:
            - team_id: str.

            - lab_tests_patient_communication_enabled: typing.Optional[bool].

            - subscription_status: typing.Optional[str].

            - logo_url: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if lab_tests_patient_communication_enabled is not OMIT:
            _request["lab_tests_patient_communication_enabled"] = lab_tests_patient_communication_enabled
        if subscription_status is not OMIT:
            _request["subscription_status"] = subscription_status
        if logo_url is not OMIT:
            _request["logo_url"] = logo_url
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TeamInDb, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_team_user_count(self, team_id: str) -> typing.Dict[str, typing.Any]:
        """
        Get the current user count for a team.

        Parameters:
            - team_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}/users/count"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def search_team_users_by_uuid_or_client_user_id(
        self, *, query_id: typing.Optional[str] = None
    ) -> typing.List[ClientFacingUser]:
        """
        Search team users by user_id

        Parameters:
            - query_id: typing.Optional[str].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/team/users/search"),
            params=remove_none_from_dict({"query_id": query_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ClientFacingUser], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_api_key(self, team_id: str, *, label: str) -> ApiKeyInDb:
        """
        Create api key.

        Parameters:
            - team_id: str.

            - label: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}/apikey"),
            json=jsonable_encoder({"label": label}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ApiKeyInDb, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_api_keys_for_team(self, team_id: str) -> typing.List[ApiKeyInDb]:
        """
        Invalidate api key by key value.

        Parameters:
            - team_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}/apikeys"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[ApiKeyInDb], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_api_key_label(self, team_id: str, api_key_id: str, *, label: str) -> ApiKeyInDb:
        """
        Update API key label.

        Parameters:
            - team_id: str.

            - api_key_id: str.

            - label: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}/apikey/{api_key_id}"),
            json=jsonable_encoder({"label": label}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ApiKeyInDb, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_api_key(self, team_id: str, api_key_id: str) -> ApiKeyInDb:
        """
        Invalidate api key by key value.

        Parameters:
            - team_id: str.

            - api_key_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}/apikey/{api_key_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ApiKeyInDb, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def rotate_api_key(self, team_id: str, api_key_id: str) -> ApiKeyInDb:
        """
        Deprecated. Rotate api key.

        Parameters:
            - team_id: str.

            - api_key_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}/apikey/{api_key_id}/rotate"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ApiKeyInDb, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_team(
        self,
        *,
        svix_app_id: typing.Optional[str] = OMIT,
        client_id: typing.Optional[str] = OMIT,
        client_secret: typing.Optional[str] = OMIT,
        api_key: typing.Optional[str] = OMIT,
        airtable_api_key: typing.Optional[str] = OMIT,
        airtable_base_id: typing.Optional[str] = OMIT,
        webhook_secret: typing.Optional[str] = OMIT,
        ff_wheel_enabled: typing.Optional[bool] = OMIT,
        ff_apple_mobile_app_enabled: typing.Optional[bool] = OMIT,
        lab_tests_patient_communication_enabled: typing.Optional[bool] = OMIT,
        lab_test_delegated_flow_enabled: typing.Optional[bool] = OMIT,
        physician_network: typing.Optional[PhysicianNetworkT] = OMIT,
        id: typing.Optional[str] = OMIT,
        name: str,
        subscription_status: typing.Optional[str] = OMIT,
    ) -> TeamInDb:
        """
        Create Team.

        Parameters:
            - svix_app_id: typing.Optional[str].

            - client_id: typing.Optional[str].

            - client_secret: typing.Optional[str].

            - api_key: typing.Optional[str].

            - airtable_api_key: typing.Optional[str].

            - airtable_base_id: typing.Optional[str].

            - webhook_secret: typing.Optional[str].

            - ff_wheel_enabled: typing.Optional[bool].

            - ff_apple_mobile_app_enabled: typing.Optional[bool].

            - lab_tests_patient_communication_enabled: typing.Optional[bool].

            - lab_test_delegated_flow_enabled: typing.Optional[bool].

            - physician_network: typing.Optional[PhysicianNetworkT].

            - id: typing.Optional[str].

            - name: str.

            - subscription_status: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {"name": name}
        if svix_app_id is not OMIT:
            _request["svix_app_id"] = svix_app_id
        if client_id is not OMIT:
            _request["client_id"] = client_id
        if client_secret is not OMIT:
            _request["client_secret"] = client_secret
        if api_key is not OMIT:
            _request["api_key"] = api_key
        if airtable_api_key is not OMIT:
            _request["airtable_api_key"] = airtable_api_key
        if airtable_base_id is not OMIT:
            _request["airtable_base_id"] = airtable_base_id
        if webhook_secret is not OMIT:
            _request["webhook_secret"] = webhook_secret
        if ff_wheel_enabled is not OMIT:
            _request["ff_wheel_enabled"] = ff_wheel_enabled
        if ff_apple_mobile_app_enabled is not OMIT:
            _request["ff_apple_mobile_app_enabled"] = ff_apple_mobile_app_enabled
        if lab_tests_patient_communication_enabled is not OMIT:
            _request["lab_tests_patient_communication_enabled"] = lab_tests_patient_communication_enabled
        if lab_test_delegated_flow_enabled is not OMIT:
            _request["lab_test_delegated_flow_enabled"] = lab_test_delegated_flow_enabled
        if physician_network is not OMIT:
            _request["physician_network"] = physician_network
        if id is not OMIT:
            _request["id"] = id
        if subscription_status is not OMIT:
            _request["subscription_status"] = subscription_status
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/team"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TeamInDb, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_priority(
        self,
        team_id: str,
        *,
        id: typing.Optional[int] = OMIT,
        priority: int,
        priority_create_team_id: str,
        source_id: int,
        data_type: typing.Optional[str] = OMIT,
    ) -> Priority:
        """
        Add Team priority row for source

        Parameters:
            - team_id: str.

            - id: typing.Optional[int].

            - priority: int.

            - priority_create_team_id: str.

            - source_id: int.

            - data_type: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {
            "priority": priority,
            "team_id": priority_create_team_id,
            "source_id": source_id,
        }
        if id is not OMIT:
            _request["id"] = id
        if data_type is not OMIT:
            _request["data_type"] = data_type
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v2/team/{team_id}/priority"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Priority, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_svix_webhook_url(self) -> typing.Dict[str, typing.Any]:
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/team/svix/url"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Dict[str, typing.Any], _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_source_priorities(
        self, *, data_type: typing.Optional[str] = None
    ) -> typing.List[typing.Dict[str, typing.Any]]:
        """
        GET source priorities.

        Parameters:
            - data_type: typing.Optional[str].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/team/source/priorities"),
            params=remove_none_from_dict({"data_type": data_type}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[typing.Dict[str, typing.Any]], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_source_priorities(self, *, team_id: str) -> typing.List[typing.Dict[str, typing.Any]]:
        """
        Patch source priorities.

        Parameters:
            - team_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v2/team/source/priorities"),
            params=remove_none_from_dict({"team_id": team_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[typing.Dict[str, typing.Any]], _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
