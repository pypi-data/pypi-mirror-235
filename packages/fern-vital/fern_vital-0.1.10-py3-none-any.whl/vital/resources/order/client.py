# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic
import typing_extensions

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.unprocessable_entity_error import UnprocessableEntityError
from ...types.consent import Consent
from ...types.fulfillment import Fulfillment
from ...types.http_validation_error import HttpValidationError
from ...types.order_status import OrderStatus
from ...types.patient_address_compatible import PatientAddressCompatible
from ...types.patient_details import PatientDetails
from ...types.physician_create_request_base import PhysicianCreateRequestBase
from ...types.post_order_response import PostOrderResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class OrderClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def register_testkit(
        self,
        *,
        user_id: str,
        sample_id: str,
        patient_details: PatientDetails,
        patient_address: PatientAddressCompatible,
        physician: typing.Optional[PhysicianCreateRequestBase] = OMIT,
        consents: typing.Optional[typing.List[Consent]] = OMIT,
    ) -> PostOrderResponse:
        """
        Parameters:
            - user_id: str.

            - sample_id: str.

            - patient_details: PatientDetails.

            - patient_address: PatientAddressCompatible.

            - physician: typing.Optional[PhysicianCreateRequestBase].

            - consents: typing.Optional[typing.List[Consent]].
        """
        _request: typing.Dict[str, typing.Any] = {
            "user_id": user_id,
            "sample_id": sample_id,
            "patient_details": patient_details,
            "patient_address": patient_address,
        }
        if physician is not OMIT:
            _request["physician"] = physician
        if consents is not OMIT:
            _request["consents"] = consents
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v3/order/testkit/register"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostOrderResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def process_testkit_order(self, order_id: str, team_id: str) -> str:
        """
        POST Create shipment for order

        Parameters:
            - order_id: str.

            - team_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v3/order/testkit/process/{team_id}/{order_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def sync_testkit_order_status(self) -> str:
        """
        This function receives requests from cloud_scheduler
        and checks the order status of the order if the order status
        in terms of the inbound delivery and outbound delivery status has
        changed. If changed then the order status is updated and a webhook
        is sent to the respective team.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v3/order/testkit/status"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def dispatch_order_status(self) -> str:
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v3/order/dispatch/status/checks"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def process_testkit_ship_hero_order_shipped(
        self, *, webhook_type: typing_extensions.Literal["Shipment Update"], fulfillment: Fulfillment
    ) -> str:
        """
        Parameters:
            - webhook_type: typing_extensions.Literal["Shipment Update"].

            - fulfillment: Fulfillment.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "v3/order/testkit/webhook/shiphero/shipment-update"
            ),
            json=jsonable_encoder({"webhook_type": webhook_type, "fulfillment": fulfillment}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def cancel_order(self, order_id: str) -> PostOrderResponse:
        """
        POST cancel order

        Parameters:
            - order_id: str. Your Order ID.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v3/order/{order_id}/cancel"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostOrderResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def order_process_simulate(
        self, order_id: str, *, final_status: typing.Optional[OrderStatus] = None, delay: typing.Optional[int] = None
    ) -> typing.Any:
        """
        Get available test kits.

        Parameters:
            - order_id: str.

            - final_status: typing.Optional[OrderStatus].

            - delay: typing.Optional[int].
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v3/order/{order_id}/test"),
            params=remove_none_from_dict({"final_status": final_status, "delay": delay}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncOrderClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def register_testkit(
        self,
        *,
        user_id: str,
        sample_id: str,
        patient_details: PatientDetails,
        patient_address: PatientAddressCompatible,
        physician: typing.Optional[PhysicianCreateRequestBase] = OMIT,
        consents: typing.Optional[typing.List[Consent]] = OMIT,
    ) -> PostOrderResponse:
        """
        Parameters:
            - user_id: str.

            - sample_id: str.

            - patient_details: PatientDetails.

            - patient_address: PatientAddressCompatible.

            - physician: typing.Optional[PhysicianCreateRequestBase].

            - consents: typing.Optional[typing.List[Consent]].
        """
        _request: typing.Dict[str, typing.Any] = {
            "user_id": user_id,
            "sample_id": sample_id,
            "patient_details": patient_details,
            "patient_address": patient_address,
        }
        if physician is not OMIT:
            _request["physician"] = physician
        if consents is not OMIT:
            _request["consents"] = consents
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v3/order/testkit/register"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostOrderResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def process_testkit_order(self, order_id: str, team_id: str) -> str:
        """
        POST Create shipment for order

        Parameters:
            - order_id: str.

            - team_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"v3/order/testkit/process/{team_id}/{order_id}"
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def sync_testkit_order_status(self) -> str:
        """
        This function receives requests from cloud_scheduler
        and checks the order status of the order if the order status
        in terms of the inbound delivery and outbound delivery status has
        changed. If changed then the order status is updated and a webhook
        is sent to the respective team.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v3/order/testkit/status"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def dispatch_order_status(self) -> str:
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "v3/order/dispatch/status/checks"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def process_testkit_ship_hero_order_shipped(
        self, *, webhook_type: typing_extensions.Literal["Shipment Update"], fulfillment: Fulfillment
    ) -> str:
        """
        Parameters:
            - webhook_type: typing_extensions.Literal["Shipment Update"].

            - fulfillment: Fulfillment.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "v3/order/testkit/webhook/shiphero/shipment-update"
            ),
            json=jsonable_encoder({"webhook_type": webhook_type, "fulfillment": fulfillment}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(str, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def cancel_order(self, order_id: str) -> PostOrderResponse:
        """
        POST cancel order

        Parameters:
            - order_id: str. Your Order ID.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v3/order/{order_id}/cancel"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PostOrderResponse, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def order_process_simulate(
        self, order_id: str, *, final_status: typing.Optional[OrderStatus] = None, delay: typing.Optional[int] = None
    ) -> typing.Any:
        """
        Get available test kits.

        Parameters:
            - order_id: str.

            - final_status: typing.Optional[OrderStatus].

            - delay: typing.Optional[int].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"v3/order/{order_id}/test"),
            params=remove_none_from_dict({"final_status": final_status, "delay": delay}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
