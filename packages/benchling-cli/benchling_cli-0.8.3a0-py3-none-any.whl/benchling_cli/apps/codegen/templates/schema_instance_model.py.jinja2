{% set instance_pascal = model_type_from_dependency(dependency).__name__ %}
{% set instance_snake = to_snake_case(instance_pascal) %}
"""Generated from manifest by `benchling-cli`.

Do not edit manually; subclass if you want to extend it.

To instantiate model and access field values:
```
{{ dependency_to_snake_case(dependency) }} = {{ dependency_to_pascal_case(dependency) }}.from_{{ instance_snake }}({{ instance_snake }})
{{ dependency_to_snake_case(dependency) }}.id  # Access native fields normally
{{ dependency_to_snake_case(dependency) }}.fields.{{ dependency_to_snake_case(dependency.field_definitions[0]) }}.value
{{ dependency_to_snake_case(dependency) }}.fields.{{ dependency_to_snake_case(dependency.field_definitions[0]) }}.display_value
```
"""
from __future__ import annotations

from copy import deepcopy
from datetime import date, datetime
from typing import Any, cast, Dict, Iterable, List, Optional, Type, TypeVar, Union

from benchling_api_client.v2.stable.types import Unset, UNSET
from benchling_sdk.apps.config.dependencies import OptionalField
from benchling_sdk.apps.config.dependencies import OptionalMultiValueField
from benchling_sdk.apps.config.dependencies import OptionalSingleOrMultiValueField
from benchling_sdk.apps.config.dependencies import RequiredField
from benchling_sdk.apps.config.dependencies import RequiredMultiValueField
from benchling_sdk.apps.config.dependencies import RequiredSingleOrMultiValueField
from benchling_sdk.apps.config.scalars import DEFAULT_SCALAR_DEFINITIONS
from benchling_sdk.apps.config.scalars import JsonType
from benchling_sdk.helpers.serialization_helpers import fields
from benchling_sdk.models import {{ instance_pascal }}, Field, Fields

T = TypeVar("T", bound="{{ dependency_to_pascal_case(dependency) }}")


class {{ dependency_to_pascal_case(dependency) }}({{ instance_pascal }}):
    fields: {{ dependency_to_pascal_case(dependency) }}Fields

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any], strict: bool = False) -> T:
        from ..parameters import dependencies
        if src_dict.get("schema"):
            actual_schema_id = src_dict["schema"]["id"]
            expected_schema_id = dependencies.{{ dependency_to_snake_case(dependency) }}.id
            assert actual_schema_id == expected_schema_id, (
                f'Resource has schema ID "{actual_schema_id}", expected "{expected_schema_id}"'
            )

        {{ dependency_to_snake_case(dependency) }} = super().from_dict(src_dict, strict=strict)
        {{ dependency_to_snake_case(dependency) }}.fields = {{ dependency_to_pascal_case(dependency) }}Fields.from_fields(cast(Fields, {{ dependency_to_snake_case(dependency) }}.fields))
        return {{ dependency_to_snake_case(dependency) }}

    @classmethod
    def from_{{ instance_snake }}(cls: Type[T], {{ instance_snake }}: {{ instance_pascal }}) -> T:
        return cls.from_dict({{ instance_snake }}.to_dict())

    @classmethod
    def from_list_endpoint(cls: Type[T], pages: Iterable[List[{{ instance_pascal }}]]) -> Iterable[T]:
        for page in pages:
            for {{ instance_snake }} in page:
                yield cls.from_{{ instance_snake }}({{ instance_snake }})


class {{ dependency_to_pascal_case(dependency) }}Fields(Fields):
    @classmethod
    def from_fields(cls, fields: Fields) -> {{ dependency_to_pascal_case(dependency) }}Fields:
        return cls.from_dict(fields.to_dict())

    @classmethod
    def from_dict(cls, src_dict: Dict[str, Any], strict: bool = False) -> {{ dependency_to_pascal_case(dependency) }}Fields:
        # Override from_dict() from super because it copies instead of deepcopy which loses nested info
        # in additional_properties dict like type
        d = deepcopy(src_dict)

        fields = {{ dependency_to_pascal_case(dependency) }}Fields()

        additional_properties = {}
        for prop_name, prop_dict in d.items():
            additional_property = Field.from_dict(prop_dict, strict=strict)

            additional_properties[prop_name] = additional_property

        fields.additional_properties = additional_properties
        return fields

    @classmethod
    def init(cls{% for field_definition in dependency.field_definitions if is_field_value_required(field_definition) %}, {{ dependency_to_snake_case(field_definition) }}: {% if is_config_multi_valued_or_unset(field_definition) is none %}Union[{{ scalar_type_name(scalar_type_from_field_config(field_definition)) }}, List[{{ scalar_type_name(scalar_type_from_field_config(field_definition)) }}]]{% elif is_config_multi_valued_or_unset(field_definition) %}List[{{ scalar_type_name(scalar_type_from_field_config(field_definition)) }}]{% else %}{{ scalar_type_name(scalar_type_from_field_config(field_definition)) }}{% endif %}{% endfor %}{% for field_definition in dependency.field_definitions if not is_field_value_required(field_definition) %}, {{ dependency_to_snake_case(field_definition) }}: Optional[Union[Unset, {% if is_config_multi_valued_or_unset(field_definition) is none %}{{ scalar_type_name(scalar_type_from_field_config(field_definition)) }}, List[{{ scalar_type_name(scalar_type_from_field_config(field_definition)) }}]{% elif is_config_multi_valued_or_unset(field_definition) %}List[{{ scalar_type_name(scalar_type_from_field_config(field_definition)) }}]{% else %}{{ scalar_type_name(scalar_type_from_field_config(field_definition)) }}{% endif %}]] = UNSET{% endfor %}) -> {{ dependency_to_pascal_case(dependency) }}Fields:
        from ..parameters import dependencies
        field_to_value: Dict[str, Any] = dict()
{% for field_definition in dependency.field_definitions %}
    {% if is_config_required(field_definition) %}
        field_to_value[dependencies.{{ dependency_to_snake_case(dependency) }}.fields.{{ dependency_to_snake_case(field_definition) }}.name] = {{ dependency_to_snake_case(field_definition) }}
    {% else %}
        if dependencies.{{ dependency_to_snake_case(dependency) }}.fields.{{ dependency_to_snake_case(field_definition) }}.name and {{ dependency_to_snake_case(field_definition) }} != UNSET:
            field_to_value[dependencies.{{ dependency_to_snake_case(dependency) }}.fields.{{ dependency_to_snake_case(field_definition) }}.name] = {{ dependency_to_snake_case(field_definition) }}
    {% endif %}
{% endfor %}
        return cls.from_fields(fields({field: {"value": value} for field, value in field_to_value.items() if value != UNSET}))
{% for field_definition in dependency.field_definitions %}

        {% set is_multi_valued = is_config_multi_valued_or_unset(field_definition) %}
        {% set scalar_type_instance = scalar_type_from_field_config(field_definition) %}
        {% set scalar_type = scalar_type_name(scalar_type_instance) %}
        {% if is_field_value_required(field_definition) %}
            {% if is_multi_valued is none %}
                {% set field_class_name = "RequiredSingleOrMultiValueField" %}
            {% elif is_multi_valued %}
                {% set field_class_name = "RequiredMultiValueField" %}
            {% else %}
                {% set field_class_name = "RequiredField" %}
            {% endif %}
        {% else %}
            {% if is_multi_valued is none %}
                {% set field_class_name = "OptionalSingleOrMultiValueField" %}
            {% elif is_multi_valued %}
                {% set field_class_name = "OptionalMultiValueField" %}
            {% else %}
                {% set field_class_name = "OptionalField" %}
            {% endif %}
        {% endif %}
        {% set field_mixin_name = field_class_name + "[" + scalar_type + "]" %}
    @property
    def {{ dependency_to_snake_case(field_definition) }}(self) -> {{ field_mixin_name }}:
        from ..parameters import dependencies

        {% if is_config_required(field_definition) %}
        field = self.additional_properties[dependencies.{{ dependency_to_snake_case(dependency) }}.fields.{{ dependency_to_snake_case(field_definition) }}.name]
        {% else %}
        field = self.additional_properties.get(dependencies.{{ dependency_to_snake_case(dependency) }}.fields.{{ dependency_to_snake_case(field_definition) }}.name) if dependencies.{{ dependency_to_snake_case(dependency) }}.fields.{{ dependency_to_snake_case(field_definition) }}.name else None
        {% endif %}
        return {{ field_class_name }}.from_field(field)
{% endfor %}